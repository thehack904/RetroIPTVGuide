<!doctype html>
<html>
<head>
    <title>Live TV Guide</title>

    <!-- Responsive viewport for mobile stability -->
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

    <!-- Small, immediate script to apply the saved theme before paint and provide a safe stub
         for setTheme so inline handlers won't throw while the full theme.js loads. -->
    <script>
    (function () {
      try {
        var t = localStorage.getItem('theme');
        if (t) document.documentElement.setAttribute('data-theme', t);
      } catch (e) { /* ignore */ }

      if (!window.setTheme) {
        window.setTheme = function (name) {
          try {
            if (name) {
              document.documentElement.setAttribute('data-theme', name);
            } else {
              document.documentElement.removeAttribute('data-theme');
            }
            try { localStorage.setItem('theme', name); } catch (e) {}
          } catch (e) { /* ignore */ }
        };
      }
    })();
    </script>

    <!-- global shared CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
    <!-- Mobile-specific overrides (loaded after base.css) -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile-submenu.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile-scroll-fix.css') }}">

    <!-- Theme script (deferred) provides setTheme/applyTheme and will wire theme controls -->
    <script src="{{ url_for('static', filename='js/theme.js') }}" defer></script>

    <!-- small per-template style block to inject server-side dynamic values used by CSS -->
    <style>
    :root {
        --timecell-width: {{ 30*SCALE }}px;
        --total-width: {{ total_width }}px;
        --now-offset: {{ now_offset }}px;
        /* optional: expose channel column width if you compute it server-side or want to override */
        --chan-col-width: 200px;
    }
    </style>
</head>
<body class="guide-page">
{% include '_header.html' %}

<!-- Player row: summary left, video right -->
<div class="player" id="playerRow">
    <div class="summary" id="summary">
        <h3>Program Info</h3>
        <p>Click a channel on the left to start playback.</p>
    </div>
    <video id="video" controls playsinline preload="metadata" tabindex="0"></video>
</div>

<!-- FIXED time header (will be populated/positioned by JS) -->
<div id="fixedTimeBar" class="time-header-fixed" aria-hidden="false" role="presentation">
    <!-- content injected by JS -->
</div>

<!-- Guide grid -->
<div class="guide-outer" id="guideOuter">
    <!-- Keep original small time header inside grid for alignment, it will be hidden when fixed header is active -->
    <div class="guide-row hide-in-grid" id="gridTimeRow">
        <div class="chan-col"><div class="chan-header"></div></div>
        <div class="grid-col">
            <div class="time-header-wrap">
                <div class="grid-content">
                    <div class="time-header">
                        {% for t in hours_header %}
                            <div class="time-cell" data-utc="{{ t.isoformat() }}">{{ t.isoformat() }}</div>
                        {% endfor %}
                    </div>
                    <div class="now-line" id="nowLineOriginal" style="display:none;"></div>
                </div>
            </div>
        </div>
    </div>

    {% for ch in channels %}
    <div class="guide-row" data-cid="{{ ch.tvg_id }}">
        <div class="chan-col">
            <div class="chan-name"
                 data-url="{{ ch.url }}"
                 data-cid="{{ ch.tvg_id }}"
                 data-name="{{ ch.name|e }}"
                 data-logo="{{ ch.logo }}">
                {% if ch.logo %}<img src="{{ ch.logo }}" alt="">{% endif %}
                <span>{{ ch.name }}</span>
            </div>
        </div>
        <div class="grid-col">
            <div class="grid-content">
            {% set cid = ch.tvg_id %}
            {% set channel_epg = epg[cid] if cid in epg else [] %}
            {% if channel_epg|length == 0 %}
                <div class="program no-guide"
                    style="left:0px; width:{{ 60 * SCALE }}px;">
                    No Guide Data Available
                </div>
            {% else %}
                {% for prog in channel_epg %}
                    {% if prog.title == 'No Guide Data Available' %}
                        <div class="program no-guide"
                            style="left:0px; width:{{ 60 * SCALE }}px;">
                            {{ prog.title }}
                        </div>
                    {% elif prog.start and prog.stop %}
                        {% set left = ((prog.start - grid_start).total_seconds()/60) * SCALE %}
                        {% set calc_width = (prog.stop - prog.start).total_seconds()/60 * SCALE %}
                        {% set width = 24 if calc_width < 24 else calc_width %}
                        <div class="program {% if prog.start <= now <= prog.stop %}now{% endif %}"
                            style="left:{{ left }}px; width:{{ width }}px;"
                            data-start="{{ prog.start.isoformat() }}"
                            data-stop="{{ prog.stop.isoformat() }}"
                            data-title="{{ prog.title }}"
                            data-desc="{{ prog.desc }}">
                            {{ prog.title }}
                        </div>
                    {% endif %}
                {% endfor %}
            {% endif %}
            </div>
        </div>
    </div>
    {% endfor %}
</div>

<script src="{{ url_for('static', filename='hls.js') }}"></script>

<script>
// --- Player, grid, and fixed timebar helpers (adapted with layout recompute hooks) ---

let hlsInstance = null;
let currentChannelId = null;

function playChannel(url, cid, name) {
    const video = document.getElementById('video');
    currentChannelId = cid;
    updateSummary(cid, name);

    fetch("/play_channel", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: "channel_name=" + encodeURIComponent(name)
    });

    if (hlsInstance) { hlsInstance.destroy(); hlsInstance = null; }
    if (Hls.isSupported()) {
        hlsInstance = new Hls();
        hlsInstance.loadSource(url);
        hlsInstance.attachMedia(video);
        hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => video.play().catch(()=>{}));
    } else {
        video.src = url;
        video.play().catch(()=>{});
    }
}

function updateSummary(cid, fallbackName) {
    const summary = document.getElementById('summary');
    const now = new Date();
    const row = document.querySelector(`.guide-row[data-cid="${cid}"]`);
    if (!row) return;

    let currentProg = null;
    row.querySelectorAll('.program').forEach(prog => {
        const start = new Date(prog.dataset.start);
        const stop = new Date(prog.dataset.stop);
        if (start <= now && stop >= now) currentProg = prog;
    });

    if (currentProg) {
        const title = currentProg.dataset.title || fallbackName;
        const desc = currentProg.dataset.desc || '';
        const start = new Date(currentProg.dataset.start);
        const stop = new Date(currentProg.dataset.stop);
        summary.innerHTML = `<h3>${title}</h3>
                             <p>${desc}</p>
                             <p>${start.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})} - ${stop.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</p>`;
    } else {
        summary.innerHTML = `<h3>${fallbackName}</h3><p>No Program Info</p>`;
    }

    // After summary content changes, re-run layout-sensitive code
    // Use rAF to ensure measurements occur after layout
    requestAnimationFrame(() => {
      if (typeof createOrUpdateFixedTimeBar === 'function') {
        createOrUpdateFixedTimeBar();
      }
      if (typeof updateNowLine === 'function') {
        updateNowLine();
      }
      // signal other adaptors (grid-adapt.js, mobile-player-adapt.js) to recompute
      window.dispatchEvent(new Event('resize'));
    });
}

/* Fixed time header function kept (unchanged behavior) */
function createOrUpdateFixedTimeBar(){
    const fixedBar = document.getElementById('fixedTimeBar');
    const gridTimeRow = document.getElementById('gridTimeRow');
    const guideOuter = document.getElementById('guideOuter');
    const playerRow = document.getElementById('playerRow');
    if (!gridTimeRow || !fixedBar || !guideOuter) return;

    const headerWrap = gridTimeRow.querySelector('.time-header-wrap .grid-content');
    const serverTimeHeader = headerWrap ? headerWrap.querySelector('.time-header') : null;
    if (!serverTimeHeader) return;

    fixedBar.innerHTML = '';

    const clonedGridContent = document.createElement('div');
    clonedGridContent.className = 'grid-content';
    clonedGridContent.style.display = 'flex';
    clonedGridContent.style.alignItems = 'stretch';
    clonedGridContent.style.position = 'relative';
    clonedGridContent.style.height = '100%';

    const spacer = document.createElement('div');
    spacer.className = 'left-spacer';

    const guideRect = guideOuter.getBoundingClientRect();
    const headerGridRect = headerWrap.getBoundingClientRect();

    let spacerWidth = Math.round(headerGridRect.left - guideRect.left);

    if (!spacerWidth || spacerWidth <= 0) {
      const firstChanCol = document.querySelector('.guide-row .chan-col');
      spacerWidth = firstChanCol ? Math.round(firstChanCol.getBoundingClientRect().width) : 200;
    }

    spacer.style.width = spacer.style.minWidth = spacer.style.maxWidth = spacerWidth + 'px';
    spacer.style.flex = '0 0 ' + spacerWidth + 'px';
    spacer.style.height = '100%';
    spacer.style.pointerEvents = 'none';

    const clonedTimeHeader = serverTimeHeader.cloneNode(true);
    clonedTimeHeader.classList.add('time-header');
    clonedTimeHeader.style.display = 'flex';
    clonedTimeHeader.style.height = '100%';

    clonedGridContent.appendChild(spacer);
    clonedGridContent.appendChild(clonedTimeHeader);

    const nowLine = document.createElement('div');
    nowLine.id = 'nowLineFixed';
    nowLine.className = 'now-line';
    nowLine.style.position = 'absolute';
    nowLine.style.top = '0';
    nowLine.style.bottom = '0';
    nowLine.style.width = '2px';
    nowLine.style.left = '0px';
    nowLine.style.pointerEvents = 'none';
    clonedGridContent.appendChild(nowLine);

    fixedBar.appendChild(clonedGridContent);

    fixedBar.style.left = '0px';
    fixedBar.style.width = window.innerWidth + 'px';

    if (playerRow) {
        const rect = playerRow.getBoundingClientRect();
        fixedBar.style.top = rect.bottom + 'px';
    } else {
        const header = document.querySelector('.header');
        const headerRect = header ? header.getBoundingClientRect() : { bottom: 40 };
        fixedBar.style.top = headerRect.bottom + 'px';
    }

    requestAnimationFrame(() => {
        const fbHeight = fixedBar.getBoundingClientRect().height || 34;
        const currentPaddingTop = parseFloat(window.getComputedStyle(guideOuter).paddingTop) || 0;
        if (currentPaddingTop < fbHeight) {
            guideOuter.style.paddingTop = fbHeight + 'px';
        }
    });

    const origNow = document.getElementById('nowLineOriginal');
    if (origNow) origNow.style.display = 'none';
}

function updateNowLine(){
    try {
      const gridStart = new Date("{{ grid_start.isoformat() }}");
      const scale = {{ SCALE }};
      const now = new Date();
      const minutesFromStart = (now - gridStart) / 60000;
      const leftPx = (minutesFromStart * scale);

      const firstChanCol = document.querySelector('.guide-row .chan-col');
      const chanColWidth = firstChanCol ? firstChanCol.getBoundingClientRect().width : 0;

      const nlFixed = document.getElementById('nowLineFixed');
      if (nlFixed) nlFixed.style.left = (leftPx + chanColWidth) + 'px';

      const nlOrig = document.getElementById('nowLineOriginal');
      if (nlOrig) nlOrig.style.left = leftPx + 'px';
    } catch(e){ console.debug('updateNowLine err', e); }
}

/* --- Initialization and bindings --- */
document.addEventListener("DOMContentLoaded", () => {
    const savedTheme = localStorage.getItem("theme") || "dark";
    // Prefer the global setTheme helper if available so theme.js / base behavior is used.
    if (savedTheme) {
      if (typeof setTheme === 'function') {
        try { setTheme(savedTheme); } catch (e) { document.documentElement.setAttribute('data-theme', savedTheme); }
      } else {
        document.documentElement.setAttribute('data-theme', savedTheme);
      }
    }

    document.querySelectorAll('.chan-name').forEach(el => {
        el.addEventListener('click', () => {
            playChannel(el.dataset.url, el.dataset.cid, el.dataset.name);
        });
    });

    document.querySelectorAll('.time-cell').forEach(cell => {
        const utc = new Date(cell.dataset.utc);
        cell.textContent = utc.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    });

    document.querySelectorAll('.program').forEach(prog => {
        const start = new Date(prog.dataset.start);
        const stop = new Date(prog.dataset.stop);
        prog.title = `${prog.dataset.title}\n${start.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})} - ${stop.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}`;
    });

    createOrUpdateFixedTimeBar();
    if (typeof updateClock === 'function') updateClock();
    updateNowLine();

    setInterval(updateClock, 1000);
    setInterval(updateNowLine, 60000);
});

/* Ensure layout recomputes on viewport resize */
window.addEventListener('resize', () => {
    // recompute fixed header placement and now-line
    if (typeof createOrUpdateFixedTimeBar === 'function') createOrUpdateFixedTimeBar();
    if (typeof updateNowLine === 'function') updateNowLine();
});

/* --- Theme & UI helpers
   The guide contains an advanced theme handler that needs to be available to the
   global theme system. We expose it as window.applyTheme so the shared theme.js
   will delegate to this implementation when available.
*/
function applyThemeGuide(theme){
  const b=document.body;
  b.classList.add("fade-switch");
  setTimeout(()=>{
    const wasTVG=b.classList.contains("tvguide1990");
    b.classList.remove("light","dark","retro-tvguide","retro-aol","retro-webtv",
                       "retro-tvguide2000","retro-magazine","directv","comcast","tvguide1990", "retroiptv");
    if (theme) b.classList.add(theme);
    try { localStorage.setItem('theme', theme); } catch (e) {}
    if(wasTVG && theme !== "tvguide1990") {
      document.querySelectorAll(".chan-col .chan-name").forEach(el=>{
        const name = el.dataset.name || "Channel";
        const logo = el.dataset.logo;
        el.innerHTML = logo ? `<img src="${logo}" alt=""><span>${name}</span>` : `<span>${name}</span>`;
      });
      document.querySelectorAll(".grid-row,.chan-col").forEach(r => r.style.height = "");
    }
    if (theme === "tvguide1990") requestAnimationFrame(applyTvGuide1990Capsules);
    setTimeout(()=>b.classList.remove("fade-switch"), 100);
  },150);
}

// expose to the shared theme system; theme.js will prefer this when calling setTheme(...)
try { window.applyTheme = applyThemeGuide; } catch (e) {}

/* applyTvGuide1990Capsules remains unchanged */
function applyTvGuide1990Capsules(){
  const originalCols = Array.from(document.querySelectorAll('.chan-col')).filter(c => !c.closest('.__auto_scroll_clone'));
  originalCols.forEach((col,i)=>{
    const box = col.querySelector('.chan-name');
    if(!box) return;
    if(box.querySelector('.channel-number')) return;
    const cap = document.createElement('span');
    cap.className='channel-number';
    cap.textContent = String(i+1);
    box.innerHTML = '';
    box.appendChild(cap);
    col.classList.add('tvguide1990-applied');
  });

  if (window.__autoScroll && typeof window.__autoScroll.recomputeLoops === 'function') {
    window.__autoScroll.recomputeLoops();
  }
}

/* Video event listeners to keep layout in sync */
document.addEventListener("DOMContentLoaded", () => {
  const video = document.getElementById('video');
  if (!video) return;

  function recomputeAll() {
    // wait a frame, then recompute
    requestAnimationFrame(() => {
      if (typeof createOrUpdateFixedTimeBar === 'function') createOrUpdateFixedTimeBar();
      if (typeof updateNowLine === 'function') updateNowLine();
      window.dispatchEvent(new Event('resize'));
    });
  }

  video.addEventListener('loadedmetadata', recomputeAll);
  video.addEventListener('play', recomputeAll);
  video.addEventListener('pause', recomputeAll);
  video.addEventListener('ended', recomputeAll);
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const el = document.getElementById('toggleAutoScroll');
  if (!el) return;

  function localPref() {
    return localStorage.getItem('autoScrollEnabled') !== 'false';
  }

  // Read preference in a way that supports several possible auto-scroll API shapes:
  // - window.__autoScroll.pref() (old)
  // - window.__autoScroll.prefValue (getter)
  // - window.__autoScroll.status().pref (newer v36.x)
  // - fall back to localStorage
  function getPrefSafe() {
    try {
      if (window.__autoScroll) {
        // status().pref is our recommended current API
        if (typeof window.__autoScroll.status === 'function') {
          const s = window.__autoScroll.status();
          if (s && typeof s.pref !== 'undefined') return Boolean(s.pref);
        }
        // older pref() function
        if (typeof window.__autoScroll.pref === 'function') return window.__autoScroll.pref();
        // prefValue getter (some versions expose it)
        if (typeof window.__autoScroll.prefValue !== 'undefined') return Boolean(window.__autoScroll.prefValue);
      }
    } catch (e) { /* ignore */ }
    return localPref();
  }

  function refreshLabel() {
    const themeActive = document.body.classList.contains('tvguide1990');
    if (themeActive) {
      el.textContent = 'Auto-Scroll disabled for TV Guide (1990)';
      el.classList.add('disabled');
      el.style.pointerEvents = 'none';
      el.title = 'Auto-Scroll is not supported for this theme.';
      return;
    }

    const enabled = getPrefSafe();
    el.textContent = enabled ? 'Disable Auto-Scroll' : 'Enable Auto-Scroll';
    el.classList.remove('disabled');
    el.style.pointerEvents = '';
    el.title = '';
  }

  el.addEventListener('click', (e) => {
    e.preventDefault();
    if (document.body.classList.contains('tvguide1990')) {
      alert('Auto-Scroll is not available for the TV Guide (1990) theme.');
      return;
    }

    // Primary: if auto-scroll exposes a toggle(), use it.
    // Secondary: if it exposes enable()/disable(), call those based on current status.
    // Fallback: update localStorage only.
    try {
      if (window.__autoScroll) {
        if (typeof window.__autoScroll.toggle === 'function') {
          window.__autoScroll.toggle();
          setTimeout(refreshLabel, 100);
          return;
        }

        // Prefer status().pref if present
        let curPref = null;
        if (typeof window.__autoScroll.status === 'function') {
          try { curPref = window.__autoScroll.status().pref; } catch (e) { curPref = null; }
        }
        // older pref() function fallback
        if (curPref === null && typeof window.__autoScroll.pref === 'function') {
          try { curPref = window.__autoScroll.pref(); } catch (e) { curPref = null; }
        }
        // prefValue getter fallback
        if (curPref === null && typeof window.__autoScroll.prefValue !== 'undefined') {
          try { curPref = Boolean(window.__autoScroll.prefValue); } catch (e) { curPref = null; }
        }

        // If enable/disable present use them
        if (typeof window.__autoScroll.enable === 'function' && typeof window.__autoScroll.disable === 'function') {
          if (curPref === null) curPref = localPref();
          if (curPref) window.__autoScroll.disable(); else window.__autoScroll.enable();
          setTimeout(refreshLabel, 100);
          return;
        }

        // last fallback: toggle localStorage (some earlier auto-scroll builds read this)
        const curLocal = localPref();
        localStorage.setItem('autoScrollEnabled', (!curLocal).toString());
        setTimeout(refreshLabel, 100);
        return;
      } else {
        // No auto-scroll script loaded: just flip localStorage flag so when it loads it'll respect the setting
        const curLocal = localPref();
        localStorage.setItem('autoScrollEnabled', (!curLocal).toString());
        setTimeout(refreshLabel, 100);
        return;
      }
    } catch (err) {
      console.error('toggleAutoScroll error', err);
      // ensure label still refreshes
      setTimeout(refreshLabel, 100);
    }
  });

  refreshLabel();

  if (window.__autoScroll) {
    // Some auto-scroll builds notify on theme changes; store a hook if supported.
    try { window.__autoScroll._onThemeChange = function () { refreshLabel(); }; } catch (e) {}
  }

  window.addEventListener('storage', (ev) => {
    if (ev.key === 'autoScrollEnabled') refreshLabel();
  });

  const bodyObserver = new MutationObserver(() => refreshLabel());
  bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] });
});
</script>

<script>
// Scroll Speed Selection Handler
document.addEventListener('DOMContentLoaded', () => {
  const speedMapping = {
    'slow': 0.6,
    'medium': 1.2,
    'fast': 2.4
  };

  // Apply saved speed on page load
  function applySavedSpeed() {
    try {
      const savedSpeed = localStorage.getItem('autoScrollSpeed') || 'medium';
      const speedValue = speedMapping[savedSpeed] || 1.2;
      if (window.__autoScroll && typeof window.__autoScroll.setSpeed === 'function') {
        window.__autoScroll.setSpeed(speedValue);
      }
    } catch (e) {
      console.debug('Failed to retrieve or apply saved auto-scroll speed from localStorage', e);
    }
  }

  // Handle speed selection clicks
  function handleSpeedClick(e) {
    e.preventDefault();
    const speed = e.target.dataset.scrollSpeed;
    if (speed && speedMapping[speed]) {
      try {
        localStorage.setItem('autoScrollSpeed', speed);
        const speedValue = speedMapping[speed];
        if (window.__autoScroll && typeof window.__autoScroll.setSpeed === 'function') {
          window.__autoScroll.setSpeed(speedValue);
          console.debug('Scroll speed set to', speed, '(' + speedValue + ' px/frame)');
        }
      } catch (e) {
        console.error('Failed to save scroll speed preference', e);
      }
    }
  }

  // Attach event listeners to all speed selection links
  document.querySelectorAll('[data-scroll-speed]').forEach(link => {
    link.addEventListener('click', handleSpeedClick);
  });

  // Apply saved speed when auto-scroll initializes
  applySavedSpeed();

  // Re-apply speed when auto-scroll is loaded (in case it loads after DOMContentLoaded)
  // Use a retry mechanism with maximum attempts to handle async script loading
  let retryCount = 0;
  const maxRetries = 5; // Max 5 attempts to find auto-scroll API
  const retryInterval = 100; // 100ms between retries (total max wait: 500ms)
  
  function retryApplySavedSpeed() {
    if (window.__autoScroll && typeof window.__autoScroll.setSpeed === 'function') {
      applySavedSpeed();
    } else if (retryCount < maxRetries) {
      retryCount++;
      setTimeout(retryApplySavedSpeed, retryInterval);
    }
  }
  
  setTimeout(retryApplySavedSpeed, retryInterval);
});
</script>

<!-- Mobile nav behavior (off-canvas toggle). Ensure this file contains the open/close and resize-dispatch code -->
<script src="{{ url_for('static', filename='js/mobile-nav.js') }}" defer></script>
<!-- Grid adapt script: computes scale on small screens so guide fits proportionally -->
<script src="{{ url_for('static', filename='js/grid-adapt.js') }}" defer></script>
<!-- Mobile player adapt script: adjusts video height based on viewport/header/fixed-timebar -->
<script src="{{ url_for('static', filename='js/mobile-player-adapt.js') }}" defer></script>
<!-- Mobile player adapt script: allow scrolling -->
<script src="{{ url_for('static', filename='js/mobile-scroll-fix.js') }}" defer></script>

<!-- Align all versions that pull from the API -->
<script src="{{ url_for('static', filename='js/guide-refresh.js') }}"></script>
<script src="{{ url_for('static', filename='js/guide-now-sync.js') }}"></script>


<!-- Auto Scroll (manager and bindings) -->
<script src="/static/js/auto-scroll.js" defer></script>

<!-- Right Hand Clock Fix -->
<script src="{{ url_for('static', filename='js/clock-fix.js') }}" defer></script>



<!-- Android / Fire / Google TV detection (keeps TV experience simple) -->
<script>
(function(){
  const ua = navigator.userAgent || "";
  const isTV = /AFT|Silk|Android\sTV|GoogleTV|MiBOX|BRAVIA|Shield|TCL|Hisense|Puffin|TV\sBro/i.test(ua);
  if (!isTV) return;

  console.log("RetroIPTVGuide: Simplifying menu for TV mode");
  document.getElementById("userAdminMenu")?.remove();
  document.getElementById("settingsMenu")?.remove();
  document.getElementById("manageUsersMenu")?.remove();

  const linksContainer = document.querySelector(".header .links");
  if (linksContainer){
    const themesMenu = document.createElement("div");
    themesMenu.className = "dropdown";
    themesMenu.innerHTML = `
      <button class="dropbtn">THEMES â–¾</button>
      <div class="dropdown-content">
        <a href="#" data-theme-selector data-theme="retroiptv">RetroIPTV</a>
        <a href="#" data-theme-selector data-theme="light">Light</a>
        <a href="#" data-theme-selector data-theme="dark">Dark</a>
        <a href="#" data-theme-selector data-theme="retro-aol">AOL / CompuServe</a>
        <a href="#" data-theme-selector data-theme="retro-magazine">TV Guide (Refresh)</a>
       <!-- <a href="#" data-theme-selector data-theme="tvguide1990">TV Guide Magazine (Classic)</a> -->
        <a href="#" data-theme-selector data-theme="directv">DirecTV</a>
        <a href="#" data-theme-selector data-theme="comcast">Comcast</a>
      </div>`;
    const logoutLink = document.querySelector('.header .links a[href*="logout"]');
    linksContainer.insertBefore(themesMenu, logoutLink);
  }
})();
</script>

</body>
</html>
