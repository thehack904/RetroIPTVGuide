<!doctype html>
<html>
<head>
    <title>Live TV Guide</title>

    <!-- Responsive viewport for mobile stability -->
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

    <!-- Apply saved display size before paint to avoid layout flash.
         Injects a CSS rule that pre-scales #appZoomRoot before display-size.js (defer)
         runs, so there is no visible flash of unstyled/unscaled content.
         display-size.js removes this tag on DOMContentLoaded and takes over with
         authoritative inline styles. -->
    <script>
    (function () {
      try {
        var ds = localStorage.getItem('displaySize');
        if (ds && ds !== 'large') {
          document.documentElement.setAttribute('data-display-size', ds);
          // Zoom factors must stay in sync with ZOOM_PRESETS in display-size.js.
          // Duplication is intentional: this script runs synchronously before any
          // external scripts (including display-size.js) load, so it cannot import.
          var ZOOM = { medium: 0.8, small: 0.67 };
          var z = ZOOM[ds];
          if (z) {
            var wPx = Math.ceil(window.innerWidth  / z);
            var hPx = Math.ceil(window.innerHeight / z);
            var s = document.createElement('style');
            s.id = '__dsinit';
            s.textContent = '#appZoomRoot{transform:scale(' + z + ');transform-origin:top left;width:' + wPx + 'px;height:' + hPx + 'px}';
            document.head.appendChild(s);
          }
        }
      } catch (e) { /* ignore */ }
    })();
    </script>

    <!-- Small, immediate script to apply the saved theme before paint and provide a safe stub
         for setTheme so inline handlers won't throw while the full theme.js loads. -->
    <script>
    (function () {
      try {
        var t = localStorage.getItem('theme');
        if (t) document.documentElement.setAttribute('data-theme', t);
      } catch (e) { /* ignore */ }

      if (!window.setTheme) {
        window.setTheme = function (name) {
          try {
            if (name) {
              document.documentElement.setAttribute('data-theme', name);
            } else {
              document.documentElement.removeAttribute('data-theme');
            }
            try { localStorage.setItem('theme', name); } catch (e) {}
          } catch (e) { /* ignore */ }
        };
      }
    })();
    </script>

    <!-- global shared CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
    <!-- Mobile-specific overrides (loaded after base.css) -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile-submenu.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile-scroll-fix.css') }}">

    <!-- Theme script (deferred) provides setTheme/applyTheme and will wire theme controls -->
    <script src="{{ url_for('static', filename='js/theme.js') }}" defer></script>
    <!-- Display size scaling (Large/Medium/Small) -->
    <script src="{{ url_for('static', filename='js/display-size.js') }}" defer></script>

    <!-- small per-template style block to inject server-side dynamic values used by CSS -->
    <style>
    :root {
        --timecell-width: {{ 30*SCALE }}px;
        --total-width: {{ total_width }}px;
        --now-offset: {{ now_offset }}px;
        /* optional: expose channel column width if you compute it server-side or want to override */
        --chan-col-width: 200px;
    }
    </style>
</head>
<body class="guide-page">
<div id="appZoomRoot">
{% include '_header.html' %}

<!-- Player row: summary left, video right -->
<div class="player" id="playerRow">
    <div class="summary" id="summary">
        <h3>Program Info</h3>
        <p>Click a channel on the left to start playback.</p>
    </div>
    <video id="video" controls playsinline preload="metadata" tabindex="0"></video>
</div>

<!-- FIXED time header (will be populated/positioned by JS) -->
<div id="fixedTimeBar" class="time-header-fixed" aria-hidden="false" role="presentation">
    <!-- content injected by JS -->
</div>

<!-- Guide grid -->
<div class="guide-outer" id="guideOuter">
    <!-- Keep original small time header inside grid for alignment, it will be hidden when fixed header is active -->
    <div class="guide-row hide-in-grid" id="gridTimeRow">
        <div class="chan-col"><div class="chan-header"></div></div>
        <div class="grid-col">
            <div class="time-header-wrap">
                <div class="grid-content">
                    <div class="time-header">
                        {% for t in hours_header %}
                            <div class="time-cell" data-utc="{{ t.isoformat() }}">{{ t.isoformat() }}</div>
                        {% endfor %}
                    </div>
                    <div class="now-line" id="nowLineOriginal" style="display:none;"></div>
                </div>
            </div>
        </div>
    </div>

    {% for ch in channels %}
    <div class="guide-row" data-cid="{{ ch.tvg_id }}">
        <div class="chan-col">
            <div class="chan-name"
                 tabindex="0"
                 role="button"
                 data-url="{{ ch.url }}"
                 data-cid="{{ ch.tvg_id }}"
                 data-name="{{ ch.name|e }}"
                 data-logo="{{ ch.logo }}">
                {% if ch.logo %}<img src="{{ ch.logo }}" alt="">{% endif %}
                <span>{{ ch.name }}</span>
            </div>
        </div>
        <div class="grid-col">
            <div class="grid-content">
            {% set cid = ch.tvg_id %}
            {% set channel_epg = epg[cid] if cid in epg else [] %}
            {% if channel_epg|length == 0 %}
                <div class="program no-guide"
                    style="left:0px; width:{{ 60 * SCALE }}px;">
                    No Guide Data Available
                </div>
            {% else %}
                {% for prog in channel_epg %}
                    {% if prog.title == 'No Guide Data Available' %}
                        <div class="program no-guide"
                            style="left:0px; width:{{ 60 * SCALE }}px;">
                            {{ prog.title }}
                        </div>
                    {% elif prog.start and prog.stop %}
                        {% set left = ((prog.start - grid_start).total_seconds()/60) * SCALE %}
                        {% set calc_width = (prog.stop - prog.start).total_seconds()/60 * SCALE %}
                        {% set width = 24 if calc_width < 24 else calc_width %}
                        <div class="program {% if prog.start <= now <= prog.stop %}now{% endif %}"
                            style="left:{{ left }}px; width:{{ width }}px;"
                            data-start="{{ prog.start.isoformat() }}"
                            data-stop="{{ prog.stop.isoformat() }}"
                            data-title="{{ prog.title }}"
                            data-desc="{{ prog.desc }}">
                            {{ prog.title }}
                        </div>
                    {% endif %}
                {% endfor %}
            {% endif %}
            </div>
        </div>
    </div>
    {% endfor %}
</div>

<script src="{{ url_for('static', filename='hls.js') }}"></script>

<!-- Inject per-user preferences so user-prefs.js can act before an extra round-trip -->
<script>window.__initialUserPrefs = {{ user_prefs | tojson }};</script>

<script>
// --- Player, grid, and fixed timebar helpers (adapted with layout recompute hooks) ---

let hlsInstance = null;
let currentChannelId = null;

/**
 * Returns the CSS zoom factor currently applied to the root <html> element via
 * data-display-size.  CSS zoom does NOT update window.innerWidth / 100vh, so any
 * JS code that sets pixel positions on position:fixed elements or compares
 * getBoundingClientRect() values (which are in visual/viewport pixels) against CSS
 * property values must divide by this factor to stay in the same coordinate space.
 * The actual value is read from the --display-zoom CSS variable set in base.css so
 * the zoom factor lives in one place rather than being duplicated in JS.
 */
/**
 * Returns the CSS zoom factor currently applied to the root <html> element via
 * data-display-size.  Delegates to the shared global helper exposed by
 * display-size.js when available; falls back to reading the CSS variable
 * directly for robustness on pages where display-size.js loads after guide.html.
 */
function getDisplayZoom() {
    if (typeof window.getDisplayZoom === 'function') return window.getDisplayZoom();
    const v = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--display-zoom'));
    return (v > 0 && isFinite(v)) ? v : 1.0;
}

function playChannel(url, cid, name) {
    const video = document.getElementById('video');
    currentChannelId = cid;
    // Expose currently-playing channel for user-prefs.js (auto-load / context menu)
    window.currentChannelMeta = { id: cid, name: name, url: url };
    updateSummary(cid, name);

    fetch("/play_channel", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: "channel_name=" + encodeURIComponent(name)
    });

    if (hlsInstance) { hlsInstance.destroy(); hlsInstance = null; }
    if (Hls.isSupported()) {
        hlsInstance = new Hls();
        hlsInstance.loadSource(url);
        hlsInstance.attachMedia(video);
        hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => video.play().catch(()=>{}));
    } else {
        video.src = url;
        video.play().catch(()=>{});
    }
}

function updateSummary(cid, fallbackName) {
    const summary = document.getElementById('summary');
    const now = new Date();
    const row = document.querySelector(`.guide-row[data-cid="${cid}"]`);
    if (!row) return;

    let currentProg = null;
    row.querySelectorAll('.program').forEach(prog => {
        const start = new Date(prog.dataset.start);
        const stop = new Date(prog.dataset.stop);
        if (start <= now && stop >= now) currentProg = prog;
    });

    if (currentProg) {
        const title = currentProg.dataset.title || fallbackName;
        const desc = currentProg.dataset.desc || '';
        const start = new Date(currentProg.dataset.start);
        const stop = new Date(currentProg.dataset.stop);
        summary.innerHTML = `<h3>${title}</h3>
                             <p>${desc}</p>
                             <p>${start.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})} - ${stop.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</p>`;
    } else {
        summary.innerHTML = `<h3>${fallbackName}</h3><p>No Program Info</p>`;
    }

    // After summary content changes, re-run layout-sensitive code
    // Use rAF to ensure measurements occur after layout
    requestAnimationFrame(() => {
      if (typeof createOrUpdateFixedTimeBar === 'function') {
        createOrUpdateFixedTimeBar();
      }
      if (typeof updateNowLine === 'function') {
        updateNowLine();
      }
      // signal other adaptors (grid-adapt.js, mobile-player-adapt.js) to recompute
      window.dispatchEvent(new Event('resize'));
    });
}

/* Fixed time header function kept (unchanged behavior) */
function createOrUpdateFixedTimeBar(){
    const fixedBar = document.getElementById('fixedTimeBar');
    const gridTimeRow = document.getElementById('gridTimeRow');
    const guideOuter = document.getElementById('guideOuter');
    const playerRow = document.getElementById('playerRow');
    if (!gridTimeRow || !fixedBar || !guideOuter) return;

    const headerWrap = gridTimeRow.querySelector('.time-header-wrap .grid-content');
    const serverTimeHeader = headerWrap ? headerWrap.querySelector('.time-header') : null;
    if (!serverTimeHeader) return;

    fixedBar.innerHTML = '';

    const clonedGridContent = document.createElement('div');
    clonedGridContent.className = 'grid-content';
    clonedGridContent.style.display = 'flex';
    clonedGridContent.style.alignItems = 'stretch';
    clonedGridContent.style.position = 'relative';
    clonedGridContent.style.height = '100%';

    const spacer = document.createElement('div');
    spacer.className = 'left-spacer';

    const guideRect = guideOuter.getBoundingClientRect();
    const headerGridRect = headerWrap.getBoundingClientRect();

    let spacerWidth = Math.round(headerGridRect.left - guideRect.left);

    if (!spacerWidth || spacerWidth <= 0) {
      const firstChanCol = document.querySelector('.guide-row .chan-col');
      spacerWidth = firstChanCol ? Math.round(firstChanCol.getBoundingClientRect().width) : 200;
    }

    const adjustedSpacerWidth = Math.ceil(spacerWidth / getDisplayZoom());
    spacer.style.width = spacer.style.minWidth = spacer.style.maxWidth = adjustedSpacerWidth + 'px';
    spacer.style.flex = '0 0 ' + adjustedSpacerWidth + 'px';
    spacer.style.height = '100%';
    spacer.style.pointerEvents = 'none';

    const clonedTimeHeader = serverTimeHeader.cloneNode(true);
    clonedTimeHeader.classList.add('time-header');
    clonedTimeHeader.style.display = 'flex';
    clonedTimeHeader.style.height = '100%';

    clonedGridContent.appendChild(spacer);
    clonedGridContent.appendChild(clonedTimeHeader);

    const nowLine = document.createElement('div');
    nowLine.id = 'nowLineFixed';
    nowLine.className = 'now-line';
    nowLine.style.position = 'absolute';
    nowLine.style.top = '0';
    nowLine.style.bottom = '0';
    nowLine.style.width = '2px';
    nowLine.style.left = '0px';
    nowLine.style.pointerEvents = 'none';
    clonedGridContent.appendChild(nowLine);

    fixedBar.appendChild(clonedGridContent);

    fixedBar.style.left = '0px';
    fixedBar.style.width = Math.ceil(window.innerWidth / getDisplayZoom()) + 'px';

    // On mobile, #appZoomRoot is position:relative + transform:scale(s), so
    // position:fixed children behave like position:absolute within appZoomRoot.
    // The CSS top must compensate for window.scrollY so the bar stays in view:
    //   top_css = (scrollY + desired_visual_y) / scale
    // On desktop, appZoomRoot is position:fixed so position:fixed children are
    // truly viewport-anchored and no scroll compensation is needed.
    const isMobileZoom = window.innerWidth <= 900 && getDisplayZoom() < 1;
    const scrollOff = isMobileZoom ? (window.scrollY || 0) : 0;

    if (playerRow) {
        const rect = playerRow.getBoundingClientRect();
        // Clamp to 0: when player scrolls off the top, anchor timebar to viewport top.
        const visualY = isMobileZoom ? Math.max(0, rect.bottom) : rect.bottom;
        fixedBar.style.top = Math.ceil((scrollOff + visualY) / getDisplayZoom()) + 'px';
    } else {
        const header = document.querySelector('.header');
        const headerRect = header ? header.getBoundingClientRect() : { bottom: 40 };
        const visualY = isMobileZoom ? Math.max(0, headerRect.bottom) : headerRect.bottom;
        fixedBar.style.top = Math.ceil((scrollOff + visualY) / getDisplayZoom()) + 'px';
    }

    requestAnimationFrame(() => {
        const zoom = getDisplayZoom();
        // getBCR returns visual/viewport px; convert to CSS px by dividing by zoom
        const fbHeightCss = Math.ceil((fixedBar.getBoundingClientRect().height || 34) / zoom);
        const currentPaddingTop = parseFloat(window.getComputedStyle(guideOuter).paddingTop) || 0;
        if (currentPaddingTop < fbHeightCss) {
            guideOuter.style.paddingTop = fbHeightCss + 'px';
        }
    });

    const origNow = document.getElementById('nowLineOriginal');
    if (origNow) origNow.style.display = 'none';
}

function updateNowLine(){
    try {
      const gridStart = new Date("{{ grid_start.isoformat() }}");
      const scale = {{ SCALE }};
      const now = new Date();
      const minutesFromStart = (now - gridStart) / 60000;
      const leftPx = (minutesFromStart * scale);

      const firstChanCol = document.querySelector('.guide-row .chan-col');
      // getBCR returns visual/viewport px; divide by zoom to get CSS px that
      // align with leftPx (which is computed in CSS px from the server SCALE)
      const chanColWidth = firstChanCol ? firstChanCol.getBoundingClientRect().width / getDisplayZoom() : 0;

      const nlFixed = document.getElementById('nowLineFixed');
      if (nlFixed) nlFixed.style.left = (leftPx + chanColWidth) + 'px';

      const nlOrig = document.getElementById('nowLineOriginal');
      if (nlOrig) nlOrig.style.left = leftPx + 'px';
    } catch(e){ console.debug('updateNowLine err', e); }
}

/* --- Initialization and bindings --- */
document.addEventListener("DOMContentLoaded", () => {
    const savedTheme = localStorage.getItem("theme") || "dark";
    // Prefer the global setTheme helper if available so theme.js / base behavior is used.
    if (savedTheme) {
      if (typeof setTheme === 'function') {
        try { setTheme(savedTheme); } catch (e) { document.documentElement.setAttribute('data-theme', savedTheme); }
      } else {
        document.documentElement.setAttribute('data-theme', savedTheme);
      }
    }

    document.querySelectorAll('.chan-name').forEach(el => {
        el.addEventListener('click', () => {
            playChannel(el.dataset.url, el.dataset.cid, el.dataset.name);
        });
    });

    document.querySelectorAll('.time-cell').forEach(cell => {
        const utc = new Date(cell.dataset.utc);
        cell.textContent = utc.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    });

    document.querySelectorAll('.program').forEach(prog => {
        const start = new Date(prog.dataset.start);
        const stop = new Date(prog.dataset.stop);
        prog.title = `${prog.dataset.title}\n${start.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})} - ${stop.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}`;
    });

    createOrUpdateFixedTimeBar();
    if (typeof updateClock === 'function') updateClock();
    updateNowLine();

    setInterval(updateClock, 1000);
    setInterval(updateNowLine, 60000);
});

/* Ensure layout recomputes on viewport resize */
window.addEventListener('resize', () => {
    // recompute fixed header placement and now-line
    if (typeof createOrUpdateFixedTimeBar === 'function') createOrUpdateFixedTimeBar();
    if (typeof updateNowLine === 'function') updateNowLine();
});

/* --- Theme & UI helpers
   The guide contains an advanced theme handler that needs to be available to the
   global theme system. We expose it as window.applyTheme so the shared theme.js
   will delegate to this implementation when available.
*/
function applyThemeGuide(theme){
  const b=document.body;
  b.classList.add("fade-switch");
  setTimeout(()=>{
    const wasTVG=b.classList.contains("tvguide1990");
    b.classList.remove("light","dark","retro-tvguide","retro-aol","retro-webtv",
                       "retro-tvguide2000","retro-magazine","directv","comcast","tvguide1990", "retroiptv");
    if (theme) b.classList.add(theme);
    try { localStorage.setItem('theme', theme); } catch (e) {}
    if(wasTVG && theme !== "tvguide1990") {
      document.querySelectorAll(".chan-col .chan-name").forEach(el=>{
        const name = el.dataset.name || "Channel";
        const logo = el.dataset.logo;
        el.innerHTML = logo ? `<img src="${logo}" alt=""><span>${name}</span>` : `<span>${name}</span>`;
      });
      document.querySelectorAll(".grid-row,.chan-col").forEach(r => r.style.height = "");
    }
    if (theme === "tvguide1990") requestAnimationFrame(applyTvGuide1990Capsules);
    setTimeout(()=>b.classList.remove("fade-switch"), 100);
  },150);
}

// expose to the shared theme system; theme.js will prefer this when calling setTheme(...)
try { window.applyTheme = applyThemeGuide; } catch (e) {}

/* applyTvGuide1990Capsules remains unchanged */
function applyTvGuide1990Capsules(){
  const originalCols = Array.from(document.querySelectorAll('.chan-col')).filter(c => !c.closest('.__auto_scroll_clone'));
  originalCols.forEach((col,i)=>{
    const box = col.querySelector('.chan-name');
    if(!box) return;
    if(box.querySelector('.channel-number')) return;
    const cap = document.createElement('span');
    cap.className='channel-number';
    cap.textContent = String(i+1);
    box.innerHTML = '';
    box.appendChild(cap);
    col.classList.add('tvguide1990-applied');
  });

  if (window.__autoScroll && typeof window.__autoScroll.recomputeLoops === 'function') {
    window.__autoScroll.recomputeLoops();
  }
}

/* Video event listeners to keep layout in sync */
document.addEventListener("DOMContentLoaded", () => {
  const video = document.getElementById('video');
  if (!video) return;

  function recomputeAll() {
    // wait a frame, then recompute
    requestAnimationFrame(() => {
      if (typeof createOrUpdateFixedTimeBar === 'function') createOrUpdateFixedTimeBar();
      if (typeof updateNowLine === 'function') updateNowLine();
      window.dispatchEvent(new Event('resize'));
    });
  }

  video.addEventListener('loadedmetadata', recomputeAll);
  video.addEventListener('play', recomputeAll);
  video.addEventListener('pause', recomputeAll);
  video.addEventListener('ended', recomputeAll);
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const el = document.getElementById('toggleAutoScroll');
  if (!el) return;

  function localPref() {
    return localStorage.getItem('autoScrollEnabled') !== 'false';
  }

  // Read preference in a way that supports several possible auto-scroll API shapes:
  // - window.__autoScroll.pref() (old)
  // - window.__autoScroll.prefValue (getter)
  // - window.__autoScroll.status().pref (newer v36.x)
  // - fall back to localStorage
  function getPrefSafe() {
    try {
      if (window.__autoScroll) {
        // status().pref is our recommended current API
        if (typeof window.__autoScroll.status === 'function') {
          const s = window.__autoScroll.status();
          if (s && typeof s.pref !== 'undefined') return Boolean(s.pref);
        }
        // older pref() function
        if (typeof window.__autoScroll.pref === 'function') return window.__autoScroll.pref();
        // prefValue getter (some versions expose it)
        if (typeof window.__autoScroll.prefValue !== 'undefined') return Boolean(window.__autoScroll.prefValue);
      }
    } catch (e) { /* ignore */ }
    return localPref();
  }

  function refreshLabel() {
    const themeActive = document.body.classList.contains('tvguide1990');
    if (themeActive) {
      el.textContent = 'Auto-Scroll disabled for TV Guide (1990)';
      el.classList.add('disabled');
      el.style.pointerEvents = 'none';
      el.title = 'Auto-Scroll is not supported for this theme.';
      return;
    }

    const enabled = getPrefSafe();
    el.textContent = enabled ? 'Disable Auto-Scroll' : 'Enable Auto-Scroll';
    el.classList.remove('disabled');
    el.style.pointerEvents = '';
    el.title = '';
  }

  el.addEventListener('click', (e) => {
    e.preventDefault();
    if (document.body.classList.contains('tvguide1990')) {
      alert('Auto-Scroll is not available for the TV Guide (1990) theme.');
      return;
    }

    // Primary: if auto-scroll exposes a toggle(), use it.
    // Secondary: if it exposes enable()/disable(), call those based on current status.
    // Fallback: update localStorage only.
    try {
      if (window.__autoScroll) {
        if (typeof window.__autoScroll.toggle === 'function') {
          window.__autoScroll.toggle();
          setTimeout(refreshLabel, 100);
          return;
        }

        // Prefer status().pref if present
        let curPref = null;
        if (typeof window.__autoScroll.status === 'function') {
          try { curPref = window.__autoScroll.status().pref; } catch (e) { curPref = null; }
        }
        // older pref() function fallback
        if (curPref === null && typeof window.__autoScroll.pref === 'function') {
          try { curPref = window.__autoScroll.pref(); } catch (e) { curPref = null; }
        }
        // prefValue getter fallback
        if (curPref === null && typeof window.__autoScroll.prefValue !== 'undefined') {
          try { curPref = Boolean(window.__autoScroll.prefValue); } catch (e) { curPref = null; }
        }

        // If enable/disable present use them
        if (typeof window.__autoScroll.enable === 'function' && typeof window.__autoScroll.disable === 'function') {
          if (curPref === null) curPref = localPref();
          if (curPref) window.__autoScroll.disable(); else window.__autoScroll.enable();
          setTimeout(refreshLabel, 100);
          return;
        }

        // last fallback: toggle localStorage (some earlier auto-scroll builds read this)
        const curLocal = localPref();
        localStorage.setItem('autoScrollEnabled', (!curLocal).toString());
        setTimeout(refreshLabel, 100);
        return;
      } else {
        // No auto-scroll script loaded: just flip localStorage flag so when it loads it'll respect the setting
        const curLocal = localPref();
        localStorage.setItem('autoScrollEnabled', (!curLocal).toString());
        setTimeout(refreshLabel, 100);
        return;
      }
    } catch (err) {
      console.error('toggleAutoScroll error', err);
      // ensure label still refreshes
      setTimeout(refreshLabel, 100);
    }
  });

  refreshLabel();

  if (window.__autoScroll) {
    // Some auto-scroll builds notify on theme changes; store a hook if supported.
    try { window.__autoScroll._onThemeChange = function () { refreshLabel(); }; } catch (e) {}
  }

  window.addEventListener('storage', (ev) => {
    if (ev.key === 'autoScrollEnabled') refreshLabel();
  });

  const bodyObserver = new MutationObserver(() => refreshLabel());
  bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] });
});
</script>

<script>
// Scroll Speed Selection Handler
document.addEventListener('DOMContentLoaded', () => {
  const speedMapping = {
    'slow': 0.6,
    'medium': 1.2,
    'fast': 2.4
  };

  // Apply saved speed on page load
  function applySavedSpeed() {
    try {
      const savedSpeed = localStorage.getItem('autoScrollSpeed') || 'medium';
      const speedValue = speedMapping[savedSpeed] || 1.2;
      if (window.__autoScroll && typeof window.__autoScroll.setSpeed === 'function') {
        window.__autoScroll.setSpeed(speedValue);
      }
    } catch (e) {
      console.debug('Failed to retrieve or apply saved auto-scroll speed from localStorage', e);
    }
  }

  // Handle speed selection clicks
  function handleSpeedClick(e) {
    e.preventDefault();
    const speed = e.target.dataset.scrollSpeed;
    if (speed && speedMapping[speed]) {
      try {
        localStorage.setItem('autoScrollSpeed', speed);
        const speedValue = speedMapping[speed];
        if (window.__autoScroll && typeof window.__autoScroll.setSpeed === 'function') {
          window.__autoScroll.setSpeed(speedValue);
          console.debug('Scroll speed set to', speed, '(' + speedValue + ' px/frame)');
        }
      } catch (e) {
        console.error('Failed to save scroll speed preference', e);
      }
    }
  }

  // Attach event listeners to all speed selection links
  document.querySelectorAll('[data-scroll-speed]').forEach(link => {
    link.addEventListener('click', handleSpeedClick);
  });

  // Apply saved speed when auto-scroll initializes
  applySavedSpeed();

  // Re-apply speed when auto-scroll is loaded (in case it loads after DOMContentLoaded)
  // Use a retry mechanism with maximum attempts to handle async script loading
  let retryCount = 0;
  const maxRetries = 5; // Max 5 attempts to find auto-scroll API
  const retryInterval = 100; // 100ms between retries (total max wait: 500ms)
  
  function retryApplySavedSpeed() {
    if (window.__autoScroll && typeof window.__autoScroll.setSpeed === 'function') {
      applySavedSpeed();
    } else if (retryCount < maxRetries) {
      retryCount++;
      setTimeout(retryApplySavedSpeed, retryInterval);
    }
  }
  
  setTimeout(retryApplySavedSpeed, retryInterval);
});
</script>

<!-- Mobile nav behavior (off-canvas toggle). Ensure this file contains the open/close and resize-dispatch code -->
<script src="{{ url_for('static', filename='js/mobile-nav.js') }}" defer></script>
<!-- Grid adapt script: computes scale on small screens so guide fits proportionally -->
<script src="{{ url_for('static', filename='js/grid-adapt.js') }}" defer></script>
<!-- Mobile player adapt script: adjusts video height based on viewport/header/fixed-timebar -->
<script src="{{ url_for('static', filename='js/mobile-player-adapt.js') }}" defer></script>
<!-- Video resize: drag handles for video/player/channel-column resizing -->
<script src="{{ url_for('static', filename='js/video-resize.js') }}" defer></script>
<!-- Mobile player adapt script: allow scrolling -->
<script src="{{ url_for('static', filename='js/mobile-scroll-fix.js') }}" defer></script>

<!-- Align all versions that pull from the API -->
<script src="{{ url_for('static', filename='js/guide-refresh.js') }}"></script>
<script src="{{ url_for('static', filename='js/guide-now-sync.js') }}"></script>


<!-- Auto Scroll (manager and bindings) -->
<script src="/static/js/auto-scroll.js" defer></script>

<!-- Right Hand Clock Fix -->
<script src="{{ url_for('static', filename='js/clock-fix.js') }}" defer></script>

<!-- Per-user channel preferences: auto-load channel, hidden channels, sizzle reels -->
<script src="{{ url_for('static', filename='js/user-prefs.js') }}" defer></script>



<!-- Android / Fire / Google TV detection (keeps TV experience simple) -->
<script>
(function(){
  const ua = navigator.userAgent || "";
  const isTV = /AFT|Silk|Android\sTV|GoogleTV|MiBOX|BRAVIA|Shield|TCL|Hisense|Puffin|TV\sBro/i.test(ua);
  if (!isTV) return;

  console.log("RetroIPTVGuide: Simplifying menu for TV mode");
  document.getElementById("userAdminMenu")?.remove();
  document.getElementById("settingsMenu")?.remove();
  document.getElementById("manageUsersMenu")?.remove();

  // Load DPAD / TV-remote channel navigation module
  var tvNavScript = document.createElement('script');
  tvNavScript.src = "{{ url_for('static', filename='js/tv-remote-nav.js') }}";
  document.body.appendChild(tvNavScript);

  const linksContainer = document.querySelector(".header .links");
  if (linksContainer){
    // SETTINGS dropdown (Auto-Scroll only) — inserted before THEMES
    const settingsTVMenu = document.createElement("div");
    settingsTVMenu.className = "dropdown";
    settingsTVMenu.innerHTML = `
      <button class="dropbtn">SETTINGS ▾</button>
      <div class="dropdown-content">
        <li class="submenu">
          <a href="#">Auto-Scroll</a>
          <ul class="submenu-content">
            <li><a href="#" id="toggleAutoScroll">Enable/Disable Auto-Scroll</a></li>
            <li class="submenu">
              <a href="#">Scroll Speed</a>
              <ul class="submenu-content">
                <li><a href="#" data-scroll-speed="slow">Slow</a></li>
                <li><a href="#" data-scroll-speed="medium">Medium</a></li>
                <li><a href="#" data-scroll-speed="fast">Fast</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li class="submenu">
          <a href="#">Display Size</a>
          <ul class="submenu-content">
            <li><a href="#" data-display-size-selector data-display-size="large">Large</a></li>
            <li><a href="#" data-display-size-selector data-display-size="medium">Medium</a></li>
            <li><a href="#" data-display-size-selector data-display-size="small">Small</a></li>
          </ul>
        </li>
      </div>`;
    const logoutLink = document.querySelector('.header .links a[href*="logout"]');
    linksContainer.insertBefore(settingsTVMenu, logoutLink);

    const themesMenu = document.createElement("div");
    themesMenu.className = "dropdown";
    themesMenu.innerHTML = `
      <button class="dropbtn">THEMES ▾</button>
      <div class="dropdown-content">
        <a href="#" data-theme-selector data-theme="retroiptv">RetroIPTV</a>
        <a href="#" data-theme-selector data-theme="light">Light</a>
        <a href="#" data-theme-selector data-theme="dark">Dark</a>
        <a href="#" data-theme-selector data-theme="retro-aol">AOL / CompuServe</a>
        <a href="#" data-theme-selector data-theme="retro-magazine">TV Guide (Refresh)</a>
       <!-- <a href="#" data-theme-selector data-theme="tvguide1990">TV Guide Magazine (Classic)</a> -->
        <a href="#" data-theme-selector data-theme="directv">DirecTV</a>
        <a href="#" data-theme-selector data-theme="comcast">Comcast</a>
      </div>`;
    linksContainer.insertBefore(themesMenu, logoutLink);
  }
})();
</script>

</div><!-- #appZoomRoot -->
</body>
</html>
