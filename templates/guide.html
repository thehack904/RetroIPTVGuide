<!doctype html>
<html>
<head>
    <title>Live TV Guide</title>

    <!-- Responsive viewport for mobile stability -->
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

    <!-- Apply saved display size before paint to avoid layout flash.
         Injects a CSS rule that pre-scales #appZoomRoot before display-size.js (defer)
         runs, so there is no visible flash of unstyled/unscaled content.
         display-size.js removes this tag on DOMContentLoaded and takes over with
         authoritative inline styles. -->
    <script>
    (function () {
      try {
        var ds = localStorage.getItem('displaySize');
        if (ds && ds !== 'large') {
          document.documentElement.setAttribute('data-display-size', ds);
          // Zoom factors must stay in sync with ZOOM_PRESETS in display-size.js.
          // Duplication is intentional: this script runs synchronously before any
          // external scripts (including display-size.js) load, so it cannot import.
          var ZOOM = { medium: 0.8, small: 0.67 };
          var z = ZOOM[ds];
          if (z) {
            var wPx = Math.ceil(window.innerWidth  / z);
            var hPx = Math.ceil(window.innerHeight / z);
            var s = document.createElement('style');
            s.id = '__dsinit';
            s.textContent = '#appZoomRoot{transform:scale(' + z + ');transform-origin:top left;width:' + wPx + 'px;height:' + hPx + 'px}';
            document.head.appendChild(s);
          }
        }
      } catch (e) { /* ignore */ }
    })();
    </script>

    <!-- Small, immediate script to apply the saved theme before paint and provide a safe stub
         for setTheme so inline handlers won't throw while the full theme.js loads. -->
    <script>
    (function () {
      try {
        var t = localStorage.getItem('theme');
        // If no localStorage value, seed from the server-side default (set via user prefs).
        {% if user_default_theme %}
        if (!t) {
          t = {{ user_default_theme | tojson }};
          try { localStorage.setItem('theme', t); } catch (e) {}
        }
        {% endif %}
        if (t) document.documentElement.setAttribute('data-theme', t);
      } catch (e) { /* ignore */ }

      if (!window.setTheme) {
        window.setTheme = function (name) {
          try {
            if (name) {
              document.documentElement.setAttribute('data-theme', name);
            } else {
              document.documentElement.removeAttribute('data-theme');
            }
            try { localStorage.setItem('theme', name); } catch (e) {}
          } catch (e) { /* ignore */ }
        };
      }
    })();
    </script>

    <!-- global shared CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
    <!-- Mobile-specific overrides (loaded after base.css) -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile-submenu.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile-scroll-fix.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/virtual-overlays.css') }}">

    <!-- Theme script (deferred) provides setTheme/applyTheme and will wire theme controls -->
    <script src="{{ url_for('static', filename='js/theme.js') }}" defer></script>
    <!-- Display size scaling (Large/Medium/Small) -->
    <script src="{{ url_for('static', filename='js/display-size.js') }}" defer></script>

    <!-- small per-template style block to inject server-side dynamic values used by CSS -->
    <style>
    :root {
        --timecell-width: {{ 30*SCALE }}px;
        --total-width: {{ total_width }}px;
        --now-offset: {{ now_offset }}px;
        /* optional: expose channel column width if you compute it server-side or want to override */
        --chan-col-width: 200px;
    }
    .video-player-wrap {
        position: relative;
        display: inline-block;
        flex-shrink: 0;
    }
    .unmute-btn {
        position: absolute;
        top: 8px;
        left: 8px;
        z-index: 25;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        border: none;
        border-radius: 4px;
        padding: 6px 12px;
        font-size: 14px;
        cursor: pointer;
        transition: background 0.15s;
    }
    .unmute-btn:hover { background: rgba(0, 0, 0, 0.9); }
    /* Virtual channel fullscreen button */
    .vc-fs-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        z-index: 25;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        border: none;
        border-radius: 4px;
        padding: 6px 10px;
        font-size: 16px;
        line-height: 1;
        cursor: pointer;
        transition: background 0.15s, opacity 0.4s;
        opacity: 1;
    }
    .vc-fs-btn:hover { background: rgba(0, 0, 0, 0.9); }
    .vc-fs-btn.vc-fs-btn-fade { opacity: 0; pointer-events: none; }
    /* Mute button sits to the left of the FS button */
    #vcMuteBtn { right: 48px; }
    /* Fill wrapper + overlay when in fullscreen (fallback for overlay types without a standalone page) */
    #videoPlayerWrap:fullscreen,
    #videoPlayerWrap:-webkit-full-screen {
        width: 100vw !important;
        height: 100vh !important;
        background: #000;
    }
    #videoPlayerWrap:fullscreen #video,
    #videoPlayerWrap:-webkit-full-screen #video {
        width: 100% !important;
        height: 100% !important;
        object-fit: cover;
    }
    /* VC fullscreen overlay â€“ shows the actual /news or /weather page in an iframe */
    #vcFsOverlay {
        position: fixed;
        inset: 0;
        z-index: 9100;
        background: #000;
        display: flex;
        align-items: stretch;
    }
    #vcFsOverlay.hidden { display: none; }
    #vcFsOverlay iframe { flex: 1; border: none; width: 100%; height: 100%; }
    #vcFsOverlayClose {
        position: absolute;
        top: 12px;
        right: 12px;
        z-index: 9110;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        border: none;
        border-radius: 4px;
        padding: 8px 14px;
        font-size: 18px;
        line-height: 1;
        cursor: pointer;
        transition: background 0.15s, opacity 0.4s;
        opacity: 1;
    }
    #vcFsOverlayClose:hover { background: rgba(0, 0, 0, 0.95); }
    #vcFsOverlayClose.vc-fs-overlay-close-fade { opacity: 0; pointer-events: none; }
    #vcFsOverlayMute {
        position: absolute;
        top: 12px;
        right: 70px;
        z-index: 9110;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        border: none;
        border-radius: 4px;
        padding: 8px 14px;
        font-size: 18px;
        line-height: 1;
        cursor: pointer;
        transition: background 0.15s, opacity 0.4s;
        opacity: 1;
    }
    #vcFsOverlayMute:hover { background: rgba(0, 0, 0, 0.95); }
    #vcFsOverlayMute.vc-fs-overlay-close-fade { opacity: 0; pointer-events: none; }
    /* Transparent layer that captures mouse events when the iframe would swallow them */
    #vcFsMouseTrap {
        position: absolute;
        inset: 0;
        z-index: 9108;
        pointer-events: none;
        cursor: default;
    }
    #vcFsMouseTrap.active { pointer-events: auto; }
    </style>
    {% if overlay_appearance.text_color or overlay_appearance.bg_color %}
    <style>
    #virtual-overlay-root {
      {% if overlay_appearance.text_color %}--vc-text-color: {{ overlay_appearance.text_color }};{% endif %}
      {% if overlay_appearance.bg_color %}--vc-bg-color: {{ overlay_appearance.bg_color }};{% endif %}
    }
    </style>
    {% endif %}
</head>
<body class="guide-page">
<div id="appZoomRoot">
{% include '_header.html' %}

<!-- Player row: summary left, video right -->
<div class="player" id="playerRow">
    <div class="summary" id="summary">
        <h3>Program Info</h3>
        <p>Click a channel on the left to start playback.</p>
    </div>
    <div class="video-player-wrap" id="videoPlayerWrap">
        <video id="video" controls playsinline preload="metadata" tabindex="0"></video>
        <button id="unmuteBtn" class="unmute-btn" hidden aria-label="Unmute video" title="Click to unmute">ðŸ”‡ Unmute</button>
        <button id="vcMuteBtn" class="vc-fs-btn" hidden aria-label="Mute virtual channel" title="Mute">ðŸ”‡</button>
        <button id="vcFsBtn" class="vc-fs-btn" hidden aria-label="Toggle virtual channel fullscreen" title="Fullscreen">â›¶</button>
        <div id="virtual-overlay-root" class="hidden" aria-hidden="true"></div>
    </div>
</div>

<!-- FIXED time header (will be populated/positioned by JS) -->
<div id="fixedTimeBar" class="time-header-fixed" aria-hidden="false" role="presentation">
    <!-- content injected by JS -->
</div>

<!-- Guide grid -->
<div class="guide-outer" id="guideOuter">
    <!-- Keep original small time header inside grid for alignment, it will be hidden when fixed header is active -->
    <div class="guide-row hide-in-grid" id="gridTimeRow">
        <div class="chan-col"><div class="chan-header"></div></div>
        <div class="grid-col">
            <div class="time-header-wrap">
                <div class="grid-content">
                    <div class="time-header">
                        {% for t in hours_header %}
                            <div class="time-cell" data-utc="{{ t.isoformat() }}">{{ t.isoformat() }}</div>
                        {% endfor %}
                    </div>
                    <div class="now-line" id="nowLineOriginal" style="display:none;"></div>
                </div>
            </div>
        </div>
    </div>

    {% for ch in channels %}
    <div class="guide-row" data-cid="{{ ch.tvg_id }}">
        <div class="chan-col">
            <div class="chan-name"
                 tabindex="0"
                 role="button"
                 data-url="{{ ch.url }}"
                 data-cid="{{ ch.tvg_id }}"
                 data-name="{{ ch.name|e }}"
                 data-logo="{{ ch.logo }}"
                 {% if ch.is_virtual %}
                 data-is-virtual="true"
                 data-loop-asset="{{ ch.loop_asset }}"
                 data-overlay-type="{{ ch.overlay_type }}"
                 data-overlay-refresh-seconds="{{ ch.overlay_refresh_seconds }}"
                 {% if ch.tvg_id not in ('virtual.weather', 'virtual.news') %}
                 {% set ch_app = channel_appearances.get(ch.tvg_id, {'text_color': '', 'bg_color': ''}) %}
                 data-overlay-text-color="{{ ch_app.text_color }}"
                 data-overlay-bg-color="{{ ch_app.bg_color }}"
                 {% endif %}
                 data-music-file="{{ channel_music_files.get(ch.tvg_id, '') }}"
                 {% endif %}>
                {% if ch.logo %}<img src="{{ ch.logo }}" alt="">{% endif %}
                <span>{{ ch.name }}</span>
            </div>
        </div>
        <div class="grid-col">
            <div class="grid-content">
            {% set cid = ch.tvg_id %}
            {% set channel_epg = epg[cid] if cid in epg else [] %}
            {% if channel_epg|length == 0 %}
                <div class="program no-guide"
                    style="left:0px; width:{{ 60 * SCALE }}px;">
                    No Guide Data Available
                </div>
            {% else %}
                {% for prog in channel_epg %}
                    {% if prog.title == 'No Guide Data Available' %}
                        <div class="program no-guide"
                            style="left:0px; width:{{ 60 * SCALE }}px;">
                            {{ prog.title }}
                        </div>
                    {% elif prog.start and prog.stop %}
                        {% set left = ((prog.start - grid_start).total_seconds()/60) * SCALE %}
                        {% set calc_width = (prog.stop - prog.start).total_seconds()/60 * SCALE %}
                        {% set width = 24 if calc_width < 24 else calc_width %}
                        <div class="program {% if prog.start <= now <= prog.stop %}now{% endif %}"
                            style="left:{{ left }}px; width:{{ width }}px;"
                            data-start="{{ prog.start.isoformat() }}"
                            data-stop="{{ prog.stop.isoformat() }}"
                            data-title="{{ prog.title }}"
                            data-desc="{{ prog.desc }}">
                            {{ prog.title }}
                        </div>
                    {% endif %}
                {% endfor %}
            {% endif %}
            </div>
        </div>
    </div>
    {% endfor %}
</div>

<script src="{{ url_for('static', filename='hls.js') }}"></script>

<!-- Inject per-user preferences so user-prefs.js can act before an extra round-trip -->
<script>window.__initialUserPrefs = {{ user_prefs | tojson }};</script>

<script>
// --- Player, grid, and fixed timebar helpers (adapted with layout recompute hooks) ---

let hlsInstance = null;
let currentChannelId = null;
let _vcCurrentOverlayType = '';
let _vcBgMuted = false;
let _vcFsHideTimer = null;
let _vcFsLastMove = 0;
let _vcFsOverlayCloseTimer = null;
let _vcFsOverlayLastMove = 0;

// â”€â”€ Background music (virtual channel looped audio) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _bgAudio = null;
let _bgAudioSrc = '';
let _bgResumeClick   = null;
let _bgResumeKeydown = null;

function _clearBgResumeListeners() {
    if (_bgResumeClick)   { document.removeEventListener('click',   _bgResumeClick,   { once: true }); _bgResumeClick   = null; }
    if (_bgResumeKeydown) { document.removeEventListener('keydown', _bgResumeKeydown, { once: true }); _bgResumeKeydown = null; }
}

function startBgMusic(src) {
    if (!src) { stopBgMusic(); return; }
    if (src === _bgAudioSrc && _bgAudio && !_bgAudio.paused) return;  // already playing
    stopBgMusic();
    _bgAudioSrc = src;
    _bgAudio = document.createElement('audio');
    _bgAudio.loop = true;
    _bgAudio.volume = 0.5;
    _bgAudio.muted = _vcBgMuted;
    _bgAudio.src = src;
    const capturedAudio = _bgAudio;
    const unmuteBtn = document.getElementById('unmuteBtn');
    _bgAudio.play().catch(function () {
        // Autoplay blocked; resume on first interaction
        if (unmuteBtn) unmuteBtn.hidden = false;
        _bgResumeClick = function () {
            _clearBgResumeListeners();
            if (unmuteBtn) unmuteBtn.hidden = true;
            capturedAudio.play().catch(function (err) { console.warn('[BgMusic] Playback failed:', err); });
        };
        _bgResumeKeydown = _bgResumeClick;
        document.addEventListener('click',   _bgResumeClick,   { once: true });
        document.addEventListener('keydown', _bgResumeKeydown, { once: true });
    });
}

function stopBgMusic() {
    _clearBgResumeListeners();
    if (_bgAudio) {
        _bgAudio.pause();
        _bgAudio.src = '';
        _bgAudio = null;
    }
    _bgAudioSrc = '';
}

// â”€â”€ Virtual channel fullscreen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function _exitVcFs() {
    if (document.fullscreenElement || document.webkitFullscreenElement) {
        (document.exitFullscreen || document.webkitExitFullscreen || function(){}).call(document);
    }
}

function _scheduleVcFsHide(delay) {
    if (_vcFsHideTimer) clearTimeout(_vcFsHideTimer);
    _vcFsHideTimer = setTimeout(function () {
        const btn = document.getElementById('vcFsBtn');
        if (btn && !btn.hidden) btn.classList.add('vc-fs-btn-fade');
        const mb = document.getElementById('vcMuteBtn');
        if (mb && !mb.hidden) mb.classList.add('vc-fs-btn-fade');
    }, delay);
}

function _scheduleOverlayCloseFade(delay) {
    if (_vcFsOverlayCloseTimer) clearTimeout(_vcFsOverlayCloseTimer);
    _vcFsOverlayCloseTimer = setTimeout(function () {
        const cb = document.getElementById('vcFsOverlayClose');
        if (cb) cb.classList.add('vc-fs-overlay-close-fade');
        const mb = document.getElementById('vcFsOverlayMute');
        if (mb) mb.classList.add('vc-fs-overlay-close-fade');
        const trap = document.getElementById('vcFsMouseTrap');
        if (trap) trap.classList.add('active');
    }, delay);
}

function _showOverlayClose() {
    const trap = document.getElementById('vcFsMouseTrap');
    if (trap) trap.classList.remove('active');
    const cb = document.getElementById('vcFsOverlayClose');
    if (cb) cb.classList.remove('vc-fs-overlay-close-fade');
    const mb = document.getElementById('vcFsOverlayMute');
    if (mb) mb.classList.remove('vc-fs-overlay-close-fade');
    _scheduleOverlayCloseFade(1500);
}

function _cancelOverlayCloseFade() {
    if (_vcFsOverlayCloseTimer) { clearTimeout(_vcFsOverlayCloseTimer); _vcFsOverlayCloseTimer = null; }
    const cb = document.getElementById('vcFsOverlayClose');
    if (cb) cb.classList.remove('vc-fs-overlay-close-fade');
    const mb = document.getElementById('vcFsOverlayMute');
    if (mb) mb.classList.remove('vc-fs-overlay-close-fade');
    const trap = document.getElementById('vcFsMouseTrap');
    if (trap) trap.classList.remove('active');
}

function _updateVcMuteBtn() {
    const icon = _vcBgMuted ? 'ðŸ”Š' : 'ðŸ”‡';
    const label = _vcBgMuted ? 'Unmute virtual channel' : 'Mute virtual channel';
    const title = _vcBgMuted ? 'Unmute' : 'Mute';
    ['vcMuteBtn', 'vcFsOverlayMute'].forEach(function (id) {
        const b = document.getElementById(id);
        if (!b) return;
        b.textContent = icon;
        b.setAttribute('aria-label', label);
        b.title = title;
    });
}

function _toggleVcMute() {
    _vcBgMuted = !_vcBgMuted;
    if (_bgAudio) _bgAudio.muted = _vcBgMuted;
    _updateVcMuteBtn();
}

function showVcFsBtn() {
    const btn = document.getElementById('vcFsBtn');
    if (!btn) return;
    btn.hidden = false;
    btn.classList.remove('vc-fs-btn-fade');
    const mb = document.getElementById('vcMuteBtn');
    if (mb) { mb.hidden = false; mb.classList.remove('vc-fs-btn-fade'); }
    _updateVcMuteBtn();
    _scheduleVcFsHide(3500);
}

function hideVcFsBtn() {
    if (_vcFsHideTimer) { clearTimeout(_vcFsHideTimer); _vcFsHideTimer = null; }
    const btn = document.getElementById('vcFsBtn');
    if (btn) {
        btn.hidden = true;
        btn.classList.remove('vc-fs-btn-fade');
    }
    const mb = document.getElementById('vcMuteBtn');
    if (mb) { mb.hidden = true; mb.classList.remove('vc-fs-btn-fade'); }
    // Close iframe overlay if active when switching away from a virtual channel.
    const overlay = document.getElementById('vcFsOverlay');
    const iframe  = document.getElementById('vcFsIframe');
    if (overlay && !overlay.classList.contains('hidden')) {
        overlay.classList.add('hidden');
        if (iframe) iframe.src = '';
    }
    // Exit fullscreen if the user switches to a normal channel while fullscreen.
    _exitVcFs();
}

document.addEventListener('DOMContentLoaded', function () {
    const btn = document.getElementById('vcFsBtn');
    if (!btn) return;
    const wrap = document.getElementById('videoPlayerWrap');

    // Overlay types that have a dedicated standalone page we can iframe in.
    // ?embedded=1 tells those pages to suppress their own audio (parent already plays it).
    const VC_PAGE_URL = { news: '/news?embedded=1', weather: '/weather?embedded=1' };

    function fsElement() {
        return document.fullscreenElement || document.webkitFullscreenElement || null;
    }

    function isOverlayFsActive() {
        const ov = document.getElementById('vcFsOverlay');
        return ov && !ov.classList.contains('hidden');
    }

    function openVcFsOverlay(pageUrl) {
        const overlay = document.getElementById('vcFsOverlay');
        const iframe  = document.getElementById('vcFsIframe');
        if (!overlay || !iframe) return;
        iframe.src = pageUrl;
        overlay.classList.remove('hidden');
        btn.textContent = 'âœ•';
        btn.title = 'Exit fullscreen';
        btn.setAttribute('aria-label', 'Exit fullscreen');
        _showOverlayClose();
        // Request true fullscreen on the overlay div so the browser chrome hides
        const req = overlay.requestFullscreen || overlay.webkitRequestFullscreen || overlay.mozRequestFullscreen;
        if (req) {
            const p = req.call(overlay);
            if (p && p.catch) p.catch(function (e) { console.warn('[VC FS overlay]', e); });
        }
    }

    function closeVcFsOverlay() {
        _cancelOverlayCloseFade();
        const overlay = document.getElementById('vcFsOverlay');
        const iframe  = document.getElementById('vcFsIframe');
        if (overlay) overlay.classList.add('hidden');
        if (iframe) iframe.src = '';  // stop network activity in iframe
        btn.textContent = 'â›¶';
        btn.title = 'Fullscreen';
        btn.setAttribute('aria-label', 'Toggle virtual channel fullscreen');
        if (fsElement()) {
            (document.exitFullscreen || document.webkitExitFullscreen || function(){}).call(document);
        }
    }

    btn.addEventListener('click', function () {
        if (isOverlayFsActive()) {
            closeVcFsOverlay();
        } else if (fsElement()) {
            _exitVcFs();
        } else {
            const pageUrl = VC_PAGE_URL[_vcCurrentOverlayType];
            if (pageUrl) {
                // news/weather: iframe the dedicated standalone page (looks identical to /news, /weather)
                openVcFsOverlay(pageUrl);
            } else {
                // Fallback for overlay types without a standalone page (e.g. 'status')
                const req = wrap.requestFullscreen || wrap.webkitRequestFullscreen || wrap.mozRequestFullscreen;
                if (req) {
                    const p = req.call(wrap);
                    if (p && p.catch) p.catch(function (e) { console.warn('[VC FS]', e); });
                }
            }
        }
    });

    const closeBtn = document.getElementById('vcFsOverlayClose');
    if (closeBtn) closeBtn.addEventListener('click', closeVcFsOverlay);

    const overlayMuteBtn = document.getElementById('vcFsOverlayMute');
    if (overlayMuteBtn) overlayMuteBtn.addEventListener('click', _toggleVcMute);

    const wrapMuteBtn = document.getElementById('vcMuteBtn');
    if (wrapMuteBtn) wrapMuteBtn.addEventListener('click', _toggleVcMute);

    _updateVcMuteBtn();  // sync aria-label / title with initial _vcBgMuted state

    // Mouse trap: when the iframe is fullscreen it swallows pointer events.
    // Activate the transparent trap div after buttons fade so any mouse movement
    // deactivates it (restoring iframe interaction) and reveals the buttons again.
    const mouseTrap = document.getElementById('vcFsMouseTrap');
    if (mouseTrap) {
        mouseTrap.addEventListener('mousemove', function () {
            if (isOverlayFsActive()) _showOverlayClose();
        });
    }

    // Close on ESC when overlay is shown but browser fullscreen was not granted
    document.addEventListener('keydown', function (e) {
        if (e.key === 'Escape' && isOverlayFsActive() && !fsElement()) {
            closeVcFsOverlay();
        }
    });

    function onFsChange() {
        const fsEl = fsElement();
        // ESC pressed while the iframe overlay was in fullscreen â†’ close overlay cleanly
        if (!fsEl && isOverlayFsActive()) {
            _cancelOverlayCloseFade();
            const overlay = document.getElementById('vcFsOverlay');
            const iframe  = document.getElementById('vcFsIframe');
            if (overlay) overlay.classList.add('hidden');
            if (iframe) iframe.src = '';
            btn.textContent = 'â›¶';
            btn.title = 'Fullscreen';
            btn.setAttribute('aria-label', 'Toggle virtual channel fullscreen');
            return;
        }
        // Wrapper-based fullscreen (fallback for 'status' and future overlay types)
        const isFs = fsEl === wrap;
        btn.textContent = isFs ? 'âœ•' : 'â›¶';
        btn.title = isFs ? 'Exit fullscreen' : 'Fullscreen';
        btn.setAttribute('aria-label', isFs ? 'Exit fullscreen' : 'Toggle virtual channel fullscreen');
    }

    document.addEventListener('fullscreenchange', onFsChange);
    document.addEventListener('webkitfullscreenchange', onFsChange);

    // Auto-hide: show button on mouse activity over the player wrap, hide after idle
    if (wrap) {
        wrap.addEventListener('mousemove', function () {
            if (!btn.hidden) {
                const now = Date.now();
                if (now - _vcFsLastMove < 250) return;
                _vcFsLastMove = now;
                btn.classList.remove('vc-fs-btn-fade');
                const mb = document.getElementById('vcMuteBtn');
                if (mb && !mb.hidden) mb.classList.remove('vc-fs-btn-fade');
                _scheduleVcFsHide(1500);
            }
        });
        wrap.addEventListener('mouseleave', function () {
            if (!btn.hidden) _scheduleVcFsHide(1500);
        });
    }

    // Auto-hide: show overlay close (âœ•) button on mouse activity inside the fullscreen overlay
    const fsOverlay = document.getElementById('vcFsOverlay');
    if (fsOverlay) {
        fsOverlay.addEventListener('mousemove', function () {
            if (isOverlayFsActive()) {
                const now = Date.now();
                if (now - _vcFsOverlayLastMove < 250) return;
                _vcFsOverlayLastMove = now;
                _showOverlayClose();
            }
        });
        fsOverlay.addEventListener('mouseleave', function () {
            if (isOverlayFsActive()) _scheduleOverlayCloseFade(1500);
        });
    }
});

/**
 * Returns the CSS zoom factor currently applied to the root <html> element via
 * data-display-size.  CSS zoom does NOT update window.innerWidth / 100vh, so any
 * JS code that sets pixel positions on position:fixed elements or compares
 * getBoundingClientRect() values (which are in visual/viewport pixels) against CSS
 * property values must divide by this factor to stay in the same coordinate space.
 * The actual value is read from the --display-zoom CSS variable set in base.css so
 * the zoom factor lives in one place rather than being duplicated in JS.
 */
/**
 * Returns the CSS zoom factor currently applied to the root <html> element via
 * data-display-size.  Delegates to the shared global helper exposed by
 * display-size.js when available; falls back to reading the CSS variable
 * directly for robustness on pages where display-size.js loads after guide.html.
 */
function getDisplayZoom() {
    if (typeof window.getDisplayZoom === 'function') return window.getDisplayZoom();
    const v = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--display-zoom'));
    return (v > 0 && isFinite(v)) ? v : 1.0;
}

function playChannel(url, cid, name) {
    const video = document.getElementById('video');
    currentChannelId = cid;
    // Expose currently-playing channel for user-prefs.js (auto-load / context menu)
    window.currentChannelMeta = { id: cid, name: name, url: url };
    updateSummary(cid, name);

    fetch("/play_channel", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: "channel_name=" + encodeURIComponent(name)
    });

    const unmuteBtn = document.getElementById('unmuteBtn');
    if (unmuteBtn) unmuteBtn.hidden = true;

    // Stop any active virtual overlay before switching channels
    if (typeof OverlayEngine !== 'undefined') OverlayEngine.stop();
    stopBgMusic();

    // Check if this is a virtual channel by looking up its element
    const escapedCid = (typeof CSS !== 'undefined' && CSS.escape) ? CSS.escape(cid) : cid.replace(/[^a-zA-Z0-9._-]/g, '\\$&');
    const chanEl = document.querySelector(`.chan-name[data-cid="${escapedCid}"]`);
    if (chanEl && chanEl.dataset.isVirtual === 'true') {
        if (hlsInstance) { hlsInstance.destroy(); hlsInstance = null; }
        const loopAsset = chanEl.dataset.loopAsset || '';
        video.loop = true;
        video.muted = true;
        video.src = loopAsset;
        video.play().catch(() => {});
        if (typeof OverlayEngine !== 'undefined') {
            OverlayEngine.start({
                type: chanEl.dataset.overlayType,
                refreshSeconds: Number(chanEl.dataset.overlayRefreshSeconds) || 60,
                textColor: chanEl.dataset.overlayTextColor || '',
                bgColor: chanEl.dataset.overlayBgColor || '',
            });
        }
        startBgMusic(chanEl.dataset.musicFile || '');
        _vcCurrentOverlayType = chanEl.dataset.overlayType || '';
        showVcFsBtn();
        return;
    }

    // Ensure any mute applied by a previous virtual channel is cleared.
    _vcCurrentOverlayType = '';
    hideVcFsBtn();
    video.muted = false;

    // Try normal play; if blocked by browser autoplay policy, retry muted
    // and show the unmute button so the user can restore audio with one click.
    function tryPlay() {
        video.play().catch(() => {
            video.muted = true;
            video.play().catch(()=>{});
            if (unmuteBtn) unmuteBtn.hidden = false;
        });
    }

    if (hlsInstance) { hlsInstance.destroy(); hlsInstance = null; }
    if (Hls.isSupported()) {
        hlsInstance = new Hls();
        hlsInstance.loadSource(url);
        hlsInstance.attachMedia(video);
        hlsInstance.on(Hls.Events.MANIFEST_PARSED, tryPlay);
    } else {
        video.src = url;
        tryPlay();
    }
}

function updateSummary(cid, fallbackName) {
    const summary = document.getElementById('summary');
    const now = new Date();
    const row = document.querySelector(`.guide-row[data-cid="${cid}"]`);
    if (!row) return;

    let currentProg = null;
    row.querySelectorAll('.program').forEach(prog => {
        const start = new Date(prog.dataset.start);
        const stop = new Date(prog.dataset.stop);
        if (start <= now && stop >= now) currentProg = prog;
    });

    if (currentProg) {
        const title = currentProg.dataset.title || fallbackName;
        const desc = currentProg.dataset.desc || '';
        const start = new Date(currentProg.dataset.start);
        const stop = new Date(currentProg.dataset.stop);
        summary.innerHTML = `<h3>${title}</h3>
                             <p>${desc}</p>
                             <p>${start.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})} - ${stop.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</p>`;
    } else {
        summary.innerHTML = `<h3>${fallbackName}</h3><p>No Program Info</p>`;
    }

    // After summary content changes, re-run layout-sensitive code
    // Use rAF to ensure measurements occur after layout
    requestAnimationFrame(() => {
      if (typeof createOrUpdateFixedTimeBar === 'function') {
        createOrUpdateFixedTimeBar();
      }
      if (typeof updateNowLine === 'function') {
        updateNowLine();
      }
      // signal other adaptors (grid-adapt.js, mobile-player-adapt.js) to recompute
      window.dispatchEvent(new Event('resize'));
    });
}

/* Fixed time header function kept (unchanged behavior) */
function createOrUpdateFixedTimeBar(){
    const fixedBar = document.getElementById('fixedTimeBar');
    const gridTimeRow = document.getElementById('gridTimeRow');
    const guideOuter = document.getElementById('guideOuter');
    const playerRow = document.getElementById('playerRow');
    if (!gridTimeRow || !fixedBar || !guideOuter) return;

    const headerWrap = gridTimeRow.querySelector('.time-header-wrap .grid-content');
    const serverTimeHeader = headerWrap ? headerWrap.querySelector('.time-header') : null;
    if (!serverTimeHeader) return;

    fixedBar.innerHTML = '';

    const clonedGridContent = document.createElement('div');
    clonedGridContent.className = 'grid-content';
    clonedGridContent.style.display = 'flex';
    clonedGridContent.style.alignItems = 'stretch';
    clonedGridContent.style.position = 'relative';
    clonedGridContent.style.height = '100%';

    const spacer = document.createElement('div');
    spacer.className = 'left-spacer';

    const guideRect = guideOuter.getBoundingClientRect();
    const headerGridRect = headerWrap.getBoundingClientRect();

    let spacerWidth = Math.round(headerGridRect.left - guideRect.left);

    if (!spacerWidth || spacerWidth <= 0) {
      const firstChanCol = document.querySelector('.guide-row .chan-col');
      spacerWidth = firstChanCol ? Math.round(firstChanCol.getBoundingClientRect().width) : 200;
    }

    const adjustedSpacerWidth = Math.ceil(spacerWidth / getDisplayZoom());
    spacer.style.width = spacer.style.minWidth = spacer.style.maxWidth = adjustedSpacerWidth + 'px';
    spacer.style.flex = '0 0 ' + adjustedSpacerWidth + 'px';
    spacer.style.height = '100%';
    spacer.style.pointerEvents = 'none';

    const clonedTimeHeader = serverTimeHeader.cloneNode(true);
    clonedTimeHeader.classList.add('time-header');
    clonedTimeHeader.style.display = 'flex';
    clonedTimeHeader.style.height = '100%';

    clonedGridContent.appendChild(spacer);
    clonedGridContent.appendChild(clonedTimeHeader);

    const nowLine = document.createElement('div');
    nowLine.id = 'nowLineFixed';
    nowLine.className = 'now-line';
    nowLine.style.position = 'absolute';
    nowLine.style.top = '0';
    nowLine.style.bottom = '0';
    nowLine.style.width = '2px';
    nowLine.style.left = '0px';
    nowLine.style.pointerEvents = 'none';
    clonedGridContent.appendChild(nowLine);

    fixedBar.appendChild(clonedGridContent);

    fixedBar.style.left = '0px';
    fixedBar.style.width = Math.ceil(window.innerWidth / getDisplayZoom()) + 'px';

    // On mobile, #appZoomRoot is position:relative + transform:scale(s), so
    // position:fixed children behave like position:absolute within appZoomRoot.
    // The CSS top must compensate for window.scrollY so the bar stays in view:
    //   top_css = (scrollY + desired_visual_y) / scale
    // On desktop, appZoomRoot is position:fixed so position:fixed children are
    // truly viewport-anchored and no scroll compensation is needed.
    const isMobileZoom = window.innerWidth <= 900 && getDisplayZoom() < 1;
    const scrollOff = isMobileZoom ? (window.scrollY || 0) : 0;

    if (playerRow) {
        const rect = playerRow.getBoundingClientRect();
        // Clamp to 0: when player scrolls off the top, anchor timebar to viewport top.
        const visualY = isMobileZoom ? Math.max(0, rect.bottom) : rect.bottom;
        fixedBar.style.top = Math.ceil((scrollOff + visualY) / getDisplayZoom()) + 'px';
    } else {
        const header = document.querySelector('.header');
        const headerRect = header ? header.getBoundingClientRect() : { bottom: 40 };
        const visualY = isMobileZoom ? Math.max(0, headerRect.bottom) : headerRect.bottom;
        fixedBar.style.top = Math.ceil((scrollOff + visualY) / getDisplayZoom()) + 'px';
    }

    requestAnimationFrame(() => {
        const zoom = getDisplayZoom();
        // getBCR returns visual/viewport px; convert to CSS px by dividing by zoom
        const fbHeightCss = Math.ceil((fixedBar.getBoundingClientRect().height || 34) / zoom);
        const currentPaddingTop = parseFloat(window.getComputedStyle(guideOuter).paddingTop) || 0;
        if (currentPaddingTop < fbHeightCss) {
            guideOuter.style.paddingTop = fbHeightCss + 'px';
        }
    });

    const origNow = document.getElementById('nowLineOriginal');
    if (origNow) origNow.style.display = 'none';
}

function updateNowLine(){
    try {
      const gridStart = new Date("{{ grid_start.isoformat() }}");
      const scale = {{ SCALE }};
      const now = new Date();
      const minutesFromStart = (now - gridStart) / 60000;
      const leftPx = (minutesFromStart * scale);

      const firstChanCol = document.querySelector('.guide-row .chan-col');
      // getBCR returns visual/viewport px; divide by zoom to get CSS px that
      // align with leftPx (which is computed in CSS px from the server SCALE)
      const chanColWidth = firstChanCol ? firstChanCol.getBoundingClientRect().width / getDisplayZoom() : 0;

      const nlFixed = document.getElementById('nowLineFixed');
      if (nlFixed) nlFixed.style.left = (leftPx + chanColWidth) + 'px';

      const nlOrig = document.getElementById('nowLineOriginal');
      if (nlOrig) nlOrig.style.left = leftPx + 'px';
    } catch(e){ console.debug('updateNowLine err', e); }
}

/* --- Initialization and bindings --- */
document.addEventListener("DOMContentLoaded", () => {
    const savedTheme = localStorage.getItem("theme") || "dark";
    // Prefer the global setTheme helper if available so theme.js / base behavior is used.
    if (savedTheme) {
      if (typeof setTheme === 'function') {
        try { setTheme(savedTheme); } catch (e) { document.documentElement.setAttribute('data-theme', savedTheme); }
      } else {
        document.documentElement.setAttribute('data-theme', savedTheme);
      }
    }

    document.querySelectorAll('.chan-name').forEach(el => {
        el.addEventListener('click', () => {
            playChannel(el.dataset.url, el.dataset.cid, el.dataset.name);
        });
    });

    const unmuteBtn = document.getElementById('unmuteBtn');
    if (unmuteBtn) {
        unmuteBtn.addEventListener('click', () => {
            const video = document.getElementById('video');
            if (video) video.muted = false;
            unmuteBtn.hidden = true;
        });
    }

    document.querySelectorAll('.time-cell').forEach(cell => {
        const utc = new Date(cell.dataset.utc);
        cell.textContent = utc.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    });

    document.querySelectorAll('.program').forEach(prog => {
        const start = new Date(prog.dataset.start);
        const stop = new Date(prog.dataset.stop);
        prog.title = `${prog.dataset.title}\n${start.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})} - ${stop.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}`;
    });

    createOrUpdateFixedTimeBar();
    if (typeof updateClock === 'function') updateClock();
    updateNowLine();

    setInterval(updateClock, 1000);
    setInterval(updateNowLine, 60000);
});

/* Ensure layout recomputes on viewport resize */
window.addEventListener('resize', () => {
    // recompute fixed header placement and now-line
    if (typeof createOrUpdateFixedTimeBar === 'function') createOrUpdateFixedTimeBar();
    if (typeof updateNowLine === 'function') updateNowLine();
});

/* --- Theme & UI helpers
   The guide contains an advanced theme handler that needs to be available to the
   global theme system. We expose it as window.applyTheme so the shared theme.js
   will delegate to this implementation when available.
*/
function applyThemeGuide(theme){
  const b=document.body;
  b.classList.add("fade-switch");
  setTimeout(()=>{
    const wasTVG=b.classList.contains("tvguide1990");
    b.classList.remove("light","dark","retro-tvguide","retro-aol","retro-webtv",
                       "retro-tvguide2000","retro-magazine","directv","comcast","tvguide1990", "retroiptv");
    if (theme) b.classList.add(theme);
    try { localStorage.setItem('theme', theme); } catch (e) {}
    if(wasTVG && theme !== "tvguide1990") {
      document.querySelectorAll(".chan-col .chan-name").forEach(el=>{
        const name = el.dataset.name || "Channel";
        const logo = el.dataset.logo;
        el.innerHTML = logo ? `<img src="${logo}" alt=""><span>${name}</span>` : `<span>${name}</span>`;
      });
      document.querySelectorAll(".grid-row,.chan-col").forEach(r => r.style.height = "");
    }
    if (theme === "tvguide1990") requestAnimationFrame(applyTvGuide1990Capsules);
    setTimeout(()=>b.classList.remove("fade-switch"), 100);
  },150);
}

// expose to the shared theme system; theme.js will prefer this when calling setTheme(...)
try { window.applyTheme = applyThemeGuide; } catch (e) {}

/* applyTvGuide1990Capsules remains unchanged */
function applyTvGuide1990Capsules(){
  const originalCols = Array.from(document.querySelectorAll('.chan-col')).filter(c => !c.closest('.__auto_scroll_clone'));
  originalCols.forEach((col,i)=>{
    const box = col.querySelector('.chan-name');
    if(!box) return;
    if(box.querySelector('.channel-number')) return;
    const cap = document.createElement('span');
    cap.className='channel-number';
    cap.textContent = String(i+1);
    box.innerHTML = '';
    box.appendChild(cap);
    col.classList.add('tvguide1990-applied');
  });

  if (window.__autoScroll && typeof window.__autoScroll.recomputeLoops === 'function') {
    window.__autoScroll.recomputeLoops();
  }
}

/* Video event listeners to keep layout in sync */
document.addEventListener("DOMContentLoaded", () => {
  const video = document.getElementById('video');
  if (!video) return;

  function recomputeAll() {
    // wait a frame, then recompute
    requestAnimationFrame(() => {
      if (typeof createOrUpdateFixedTimeBar === 'function') createOrUpdateFixedTimeBar();
      if (typeof updateNowLine === 'function') updateNowLine();
      window.dispatchEvent(new Event('resize'));
    });
  }

  video.addEventListener('loadedmetadata', recomputeAll);
  video.addEventListener('play', recomputeAll);
  video.addEventListener('pause', recomputeAll);
  video.addEventListener('ended', recomputeAll);
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const el = document.getElementById('toggleAutoScroll');
  if (!el) return;

  function localPref() {
    return localStorage.getItem('autoScrollEnabled') !== 'false';
  }

  // Read preference in a way that supports several possible auto-scroll API shapes:
  // - window.__autoScroll.pref() (old)
  // - window.__autoScroll.prefValue (getter)
  // - window.__autoScroll.status().pref (newer v36.x)
  // - fall back to localStorage
  function getPrefSafe() {
    try {
      if (window.__autoScroll) {
        // status().pref is our recommended current API
        if (typeof window.__autoScroll.status === 'function') {
          const s = window.__autoScroll.status();
          if (s && typeof s.pref !== 'undefined') return Boolean(s.pref);
        }
        // older pref() function
        if (typeof window.__autoScroll.pref === 'function') return window.__autoScroll.pref();
        // prefValue getter (some versions expose it)
        if (typeof window.__autoScroll.prefValue !== 'undefined') return Boolean(window.__autoScroll.prefValue);
      }
    } catch (e) { /* ignore */ }
    return localPref();
  }

  function refreshLabel() {
    const themeActive = document.body.classList.contains('tvguide1990');
    if (themeActive) {
      el.textContent = 'Auto-Scroll disabled for TV Guide (1990)';
      el.classList.add('disabled');
      el.style.pointerEvents = 'none';
      el.title = 'Auto-Scroll is not supported for this theme.';
      return;
    }

    const enabled = getPrefSafe();
    el.textContent = enabled ? 'Disable Auto-Scroll' : 'Enable Auto-Scroll';
    el.classList.remove('disabled');
    el.style.pointerEvents = '';
    el.title = '';
  }

  el.addEventListener('click', (e) => {
    e.preventDefault();
    if (document.body.classList.contains('tvguide1990')) {
      alert('Auto-Scroll is not available for the TV Guide (1990) theme.');
      return;
    }

    // Primary: if auto-scroll exposes a toggle(), use it.
    // Secondary: if it exposes enable()/disable(), call those based on current status.
    // Fallback: update localStorage only.
    try {
      if (window.__autoScroll) {
        if (typeof window.__autoScroll.toggle === 'function') {
          window.__autoScroll.toggle();
          setTimeout(refreshLabel, 100);
          return;
        }

        // Prefer status().pref if present
        let curPref = null;
        if (typeof window.__autoScroll.status === 'function') {
          try { curPref = window.__autoScroll.status().pref; } catch (e) { curPref = null; }
        }
        // older pref() function fallback
        if (curPref === null && typeof window.__autoScroll.pref === 'function') {
          try { curPref = window.__autoScroll.pref(); } catch (e) { curPref = null; }
        }
        // prefValue getter fallback
        if (curPref === null && typeof window.__autoScroll.prefValue !== 'undefined') {
          try { curPref = Boolean(window.__autoScroll.prefValue); } catch (e) { curPref = null; }
        }

        // If enable/disable present use them
        if (typeof window.__autoScroll.enable === 'function' && typeof window.__autoScroll.disable === 'function') {
          if (curPref === null) curPref = localPref();
          if (curPref) window.__autoScroll.disable(); else window.__autoScroll.enable();
          setTimeout(refreshLabel, 100);
          return;
        }

        // last fallback: toggle localStorage (some earlier auto-scroll builds read this)
        const curLocal = localPref();
        localStorage.setItem('autoScrollEnabled', (!curLocal).toString());
        setTimeout(refreshLabel, 100);
        return;
      } else {
        // No auto-scroll script loaded: just flip localStorage flag so when it loads it'll respect the setting
        const curLocal = localPref();
        localStorage.setItem('autoScrollEnabled', (!curLocal).toString());
        setTimeout(refreshLabel, 100);
        return;
      }
    } catch (err) {
      console.error('toggleAutoScroll error', err);
      // ensure label still refreshes
      setTimeout(refreshLabel, 100);
    }
  });

  refreshLabel();

  if (window.__autoScroll) {
    // Some auto-scroll builds notify on theme changes; store a hook if supported.
    try { window.__autoScroll._onThemeChange = function () { refreshLabel(); }; } catch (e) {}
  }

  window.addEventListener('storage', (ev) => {
    if (ev.key === 'autoScrollEnabled') refreshLabel();
  });

  const bodyObserver = new MutationObserver(() => refreshLabel());
  bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] });
});
</script>

<script>
// Scroll Speed Selection Handler
document.addEventListener('DOMContentLoaded', () => {
  const speedMapping = {
    'slow': 0.6,
    'medium': 1.2,
    'fast': 2.4
  };

  // Apply saved speed on page load
  function applySavedSpeed() {
    try {
      const savedSpeed = localStorage.getItem('autoScrollSpeed') || 'medium';
      const speedValue = speedMapping[savedSpeed] || 1.2;
      if (window.__autoScroll && typeof window.__autoScroll.setSpeed === 'function') {
        window.__autoScroll.setSpeed(speedValue);
      }
    } catch (e) {
      console.debug('Failed to retrieve or apply saved auto-scroll speed from localStorage', e);
    }
  }

  // Handle speed selection clicks
  function handleSpeedClick(e) {
    e.preventDefault();
    const speed = e.target.dataset.scrollSpeed;
    if (speed && speedMapping[speed]) {
      try {
        localStorage.setItem('autoScrollSpeed', speed);
        const speedValue = speedMapping[speed];
        if (window.__autoScroll && typeof window.__autoScroll.setSpeed === 'function') {
          window.__autoScroll.setSpeed(speedValue);
          console.debug('Scroll speed set to', speed, '(' + speedValue + ' px/frame)');
        }
      } catch (e) {
        console.error('Failed to save scroll speed preference', e);
      }
    }
  }

  // Attach event listeners to all speed selection links
  document.querySelectorAll('[data-scroll-speed]').forEach(link => {
    link.addEventListener('click', handleSpeedClick);
  });

  // Apply saved speed when auto-scroll initializes
  applySavedSpeed();

  // Re-apply speed when auto-scroll is loaded (in case it loads after DOMContentLoaded)
  // Use a retry mechanism with maximum attempts to handle async script loading
  let retryCount = 0;
  const maxRetries = 5; // Max 5 attempts to find auto-scroll API
  const retryInterval = 100; // 100ms between retries (total max wait: 500ms)
  
  function retryApplySavedSpeed() {
    if (window.__autoScroll && typeof window.__autoScroll.setSpeed === 'function') {
      applySavedSpeed();
    } else if (retryCount < maxRetries) {
      retryCount++;
      setTimeout(retryApplySavedSpeed, retryInterval);
    }
  }
  
  setTimeout(retryApplySavedSpeed, retryInterval);
});
</script>

<!-- Mobile nav behavior (off-canvas toggle). Ensure this file contains the open/close and resize-dispatch code -->
<script src="{{ url_for('static', filename='js/mobile-nav.js') }}" defer></script>
<!-- Grid adapt script: computes scale on small screens so guide fits proportionally -->
<script src="{{ url_for('static', filename='js/grid-adapt.js') }}" defer></script>
<!-- Mobile player adapt script: adjusts video height based on viewport/header/fixed-timebar -->
<script src="{{ url_for('static', filename='js/mobile-player-adapt.js') }}" defer></script>
<!-- Video resize: drag handles for video/player/channel-column resizing -->
<script src="{{ url_for('static', filename='js/video-resize.js') }}" defer></script>
<!-- Mobile player adapt script: allow scrolling -->
<script src="{{ url_for('static', filename='js/mobile-scroll-fix.js') }}" defer></script>

<!-- Align all versions that pull from the API -->
<script src="{{ url_for('static', filename='js/guide-refresh.js') }}"></script>
<script src="{{ url_for('static', filename='js/guide-now-sync.js') }}"></script>


<!-- Auto Scroll (manager and bindings) -->
<script src="/static/js/auto-scroll.js" defer></script>

<!-- Right Hand Clock Fix -->
<script src="{{ url_for('static', filename='js/clock-fix.js') }}" defer></script>

<!-- Per-user channel preferences: auto-load channel, hidden channels, sizzle reels -->
<script src="{{ url_for('static', filename='js/user-prefs.js') }}" defer></script>



<!-- Android / Fire / Google TV detection (keeps TV experience simple) -->
<script>
(function(){
  const ua = navigator.userAgent || "";
  const isTV = /AFT|Silk|Android\sTV|GoogleTV|MiBOX|BRAVIA|Shield|TCL|Hisense|Puffin|TV\sBro/i.test(ua);
  if (!isTV) return;

  console.log("RetroIPTVGuide: Simplifying menu for TV mode");
  document.getElementById("userAdminMenu")?.remove();
  document.getElementById("settingsMenu")?.remove();
  document.getElementById("manageUsersMenu")?.remove();

  // Load DPAD / TV-remote channel navigation module
  var tvNavScript = document.createElement('script');
  tvNavScript.src = "{{ url_for('static', filename='js/tv-remote-nav.js') }}";
  document.body.appendChild(tvNavScript);

  const linksContainer = document.querySelector(".header .links");
  if (linksContainer){
    // SETTINGS dropdown (Auto-Scroll only) â€” inserted before THEMES
    const settingsTVMenu = document.createElement("div");
    settingsTVMenu.className = "dropdown";
    settingsTVMenu.innerHTML = `
      <button class="dropbtn">SETTINGS â–¾</button>
      <div class="dropdown-content">
        <li class="submenu">
          <a href="#">Auto-Scroll</a>
          <ul class="submenu-content">
            <li><a href="#" id="toggleAutoScroll">Enable/Disable Auto-Scroll</a></li>
            <li class="submenu">
              <a href="#">Scroll Speed</a>
              <ul class="submenu-content">
                <li><a href="#" data-scroll-speed="slow">Slow</a></li>
                <li><a href="#" data-scroll-speed="medium">Medium</a></li>
                <li><a href="#" data-scroll-speed="fast">Fast</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li class="submenu">
          <a href="#">Display Size</a>
          <ul class="submenu-content">
            <li><a href="#" data-display-size-selector data-display-size="large">Large</a></li>
            <li><a href="#" data-display-size-selector data-display-size="medium">Medium</a></li>
            <li><a href="#" data-display-size-selector data-display-size="small">Small</a></li>
          </ul>
        </li>
      </div>`;
    const logoutLink = document.querySelector('.header .links a[href*="logout"]');
    linksContainer.insertBefore(settingsTVMenu, logoutLink);

    const themesMenu = document.createElement("div");
    themesMenu.className = "dropdown";
    themesMenu.innerHTML = `
      <button class="dropbtn">THEMES â–¾</button>
      <div class="dropdown-content">
        <a href="#" data-theme-selector data-theme="retroiptv">RetroIPTV</a>
        <a href="#" data-theme-selector data-theme="light">Light</a>
        <a href="#" data-theme-selector data-theme="dark">Dark</a>
        <a href="#" data-theme-selector data-theme="retro-aol">AOL / CompuServe</a>
        <a href="#" data-theme-selector data-theme="retro-magazine">TV Guide (Refresh)</a>
       <!-- <a href="#" data-theme-selector data-theme="tvguide1990">TV Guide Magazine (Classic)</a> -->
        <a href="#" data-theme-selector data-theme="directv">DirecTV</a>
        <a href="#" data-theme-selector data-theme="comcast">Comcast</a>
      </div>`;
    linksContainer.insertBefore(themesMenu, logoutLink);
  }
})();
</script>

<script src="{{ url_for('static', filename='overlays/overlay-engine.js') }}"></script>
<script src="{{ url_for('static', filename='overlays/news.js') }}"></script>
<script src="{{ url_for('static', filename='overlays/weather.js') }}"></script>
<script src="{{ url_for('static', filename='overlays/status.js') }}"></script>

</div><!-- #appZoomRoot -->

<!-- Virtual channel fullscreen overlay â€“ iframes the dedicated /news or /weather page so
     fullscreen appearance is identical to those standalone pages. Background music keeps
     playing in the parent page (outside this iframe). -->
<div id="vcFsOverlay" class="hidden" role="dialog" aria-modal="true" aria-label="Virtual channel fullscreen">
    <button id="vcFsOverlayMute" aria-label="Mute virtual channel" title="Mute">ðŸ”‡</button>
    <button id="vcFsOverlayClose" aria-label="Close fullscreen">âœ•</button>
    <div id="vcFsMouseTrap"></div>
    <iframe id="vcFsIframe" src="" title="Virtual channel" allow="autoplay"></iframe>
</div>
</body>
</html>
